"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-easy-crop";
exports.ids = ["vendor-chunks/react-easy-crop"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-easy-crop/index.module.js":
/*!******************************************************!*\
  !*** ./node_modules/react-easy-crop/index.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Cropper),\n/* harmony export */   getInitialCropFromCroppedAreaPercentages: () => (/* binding */ getInitialCropFromCroppedAreaPercentages),\n/* harmony export */   getInitialCropFromCroppedAreaPixels: () => (/* binding */ getInitialCropFromCroppedAreaPixels)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/react-easy-crop/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var normalize_wheel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! normalize-wheel */ \"(ssr)/./node_modules/normalize-wheel/index.js\");\n/* harmony import */ var normalize_wheel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(normalize_wheel__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n/**\r\n * Compute the dimension of the crop area based on media size,\r\n * aspect ratio and optionally rotation\r\n */\nfunction getCropSize(mediaWidth, mediaHeight, containerWidth, containerHeight, aspect, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var _a = rotateSize(mediaWidth, mediaHeight, rotation),\n    width = _a.width,\n    height = _a.height;\n  var fittingWidth = Math.min(width, containerWidth);\n  var fittingHeight = Math.min(height, containerHeight);\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight\n    };\n  }\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect\n  };\n}\n/**\r\n * Compute media zoom.\r\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\r\n */\nfunction getMediaZoom(mediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height ? mediaSize.width / mediaSize.naturalWidth : mediaSize.height / mediaSize.naturalHeight;\n}\n/**\r\n * Ensure a new media position stays in the crop area.\r\n */\nfunction restrictPosition(position, mediaSize, cropSize, zoom, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var _a = rotateSize(mediaSize.width, mediaSize.height, rotation),\n    width = _a.width,\n    height = _a.height;\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)\n  };\n}\nfunction restrictPositionCoord(position, mediaSize, cropSize, zoom) {\n  var maxPosition = mediaSize * zoom / 2 - cropSize / 2;\n  return clamp(position, -maxPosition, maxPosition);\n}\nfunction getDistanceBetweenPoints(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));\n}\nfunction getRotationBetweenPoints(pointA, pointB) {\n  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;\n}\n/**\r\n * Compute the output cropped area of the media in percentages and pixels.\r\n * x/y are the top-left coordinates on the src media\r\n */\nfunction computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  if (restrictPosition === void 0) {\n    restrictPosition = true;\n  }\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  var limitAreaFn = restrictPosition ? limitArea : noOp;\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);\n  // calculate the crop area in percentages\n  // in the rotated space\n  var croppedAreaPercentages = {\n    x: limitAreaFn(100, ((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width * 100),\n    y: limitAreaFn(100, ((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaBBoxSize.height * 100),\n    width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),\n    height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)\n  };\n  // we compute the pixels size naively\n  var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));\n  var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));\n  var isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect;\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  var sizePixels = isImgWiderThanHigh ? {\n    width: Math.round(heightInPixels * aspect),\n    height: heightInPixels\n  } : {\n    width: widthInPixels,\n    height: Math.round(widthInPixels / aspect)\n  };\n  var croppedAreaPixels = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, sizePixels), {\n    x: Math.round(limitAreaFn(mediaNaturalBBoxSize.width - sizePixels.width, croppedAreaPercentages.x * mediaNaturalBBoxSize.width / 100)),\n    y: Math.round(limitAreaFn(mediaNaturalBBoxSize.height - sizePixels.height, croppedAreaPercentages.y * mediaNaturalBBoxSize.height / 100))\n  });\n  return {\n    croppedAreaPercentages: croppedAreaPercentages,\n    croppedAreaPixels: croppedAreaPixels\n  };\n}\n/**\r\n * Ensure the returned value is between 0 and max\r\n */\nfunction limitArea(max, value) {\n  return Math.min(max, Math.max(0, value));\n}\nfunction noOp(_max, value) {\n  return value;\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPercentages.\r\n */\nfunction getInitialCropFromCroppedAreaPercentages(croppedAreaPercentages, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);\n  // This is the inverse process of computeCroppedArea\n  var zoom = clamp(cropSize.width / mediaBBoxSize.width * (100 / croppedAreaPercentages.width), minZoom, maxZoom);\n  var crop = {\n    x: zoom * mediaBBoxSize.width / 2 - cropSize.width / 2 - mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y: zoom * mediaBBoxSize.height / 2 - cropSize.height / 2 - mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100)\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Compute zoom from the croppedAreaPixels\r\n */\nfunction getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {\n  var mediaZoom = getMediaZoom(mediaSize);\n  return cropSize.height > cropSize.width ? cropSize.height / (croppedAreaPixels.height * mediaZoom) : cropSize.width / (croppedAreaPixels.width * mediaZoom);\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPixels\r\n */\nfunction getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);\n  var zoom = clamp(getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize), minZoom, maxZoom);\n  var cropZoom = cropSize.height > cropSize.width ? cropSize.height / croppedAreaPixels.height : cropSize.width / croppedAreaPixels.width;\n  var crop = {\n    x: ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Return the point that is the center of point a and b\r\n */\nfunction getCenter(a, b) {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2\n  };\n}\nfunction getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\nfunction rotateSize(width, height, rotation) {\n  var rotRad = getRadianAngle(rotation);\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)\n  };\n}\n/**\r\n * Clamp value between min and max\r\n */\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Combine multiple class names into a single string.\r\n */\nfunction classNames() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return args.filter(function (value) {\n    if (typeof value === 'string' && value.length > 0) {\n      return true;\n    }\n    return false;\n  }).join(' ').trim();\n}\n\nvar css_248z = \".reactEasyCrop_Container {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  overflow: hidden;\\n  user-select: none;\\n  touch-action: none;\\n  cursor: move;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.reactEasyCrop_Image,\\n.reactEasyCrop_Video {\\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\\n}\\n\\n.reactEasyCrop_Contain {\\n  max-width: 100%;\\n  max-height: 100%;\\n  margin: auto;\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n}\\n.reactEasyCrop_Cover_Horizontal {\\n  width: 100%;\\n  height: auto;\\n}\\n.reactEasyCrop_Cover_Vertical {\\n  width: auto;\\n  height: 100%;\\n}\\n\\n.reactEasyCrop_CropArea {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  box-sizing: border-box;\\n  box-shadow: 0 0 0 9999em;\\n  color: rgba(0, 0, 0, 0.5);\\n  overflow: hidden;\\n}\\n\\n.reactEasyCrop_CropAreaRound {\\n  border-radius: 50%;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::before {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 0;\\n  bottom: 0;\\n  left: 33.33%;\\n  right: 33.33%;\\n  border-top: 0;\\n  border-bottom: 0;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::after {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 33.33%;\\n  bottom: 33.33%;\\n  left: 0;\\n  right: 0;\\n  border-left: 0;\\n  border-right: 0;\\n}\\n\";\n\nvar MIN_ZOOM = 1;\nvar MAX_ZOOM = 3;\nvar Cropper = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Cropper, _super);\n  function Cropper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.imageRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    _this.videoRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    _this.containerPosition = {\n      x: 0,\n      y: 0\n    };\n    _this.containerRef = null;\n    _this.styleRef = null;\n    _this.containerRect = null;\n    _this.mediaSize = {\n      width: 0,\n      height: 0,\n      naturalWidth: 0,\n      naturalHeight: 0\n    };\n    _this.dragStartPosition = {\n      x: 0,\n      y: 0\n    };\n    _this.dragStartCrop = {\n      x: 0,\n      y: 0\n    };\n    _this.gestureZoomStart = 0;\n    _this.gestureRotationStart = 0;\n    _this.isTouching = false;\n    _this.lastPinchDistance = 0;\n    _this.lastPinchRotation = 0;\n    _this.rafDragTimeout = null;\n    _this.rafPinchTimeout = null;\n    _this.wheelTimer = null;\n    _this.currentDoc = typeof document !== 'undefined' ? document : null;\n    _this.currentWindow = typeof window !== 'undefined' ? window : null;\n    _this.resizeObserver = null;\n    _this.state = {\n      cropSize: null,\n      hasWheelJustStarted: false,\n      mediaObjectFit: undefined\n    };\n    _this.initResizeObserver = function () {\n      if (typeof window.ResizeObserver === 'undefined' || !_this.containerRef) {\n        return;\n      }\n      var isFirstResize = true;\n      _this.resizeObserver = new window.ResizeObserver(function (entries) {\n        if (isFirstResize) {\n          isFirstResize = false; // observe() is called on mount, we don't want to trigger a recompute on mount\n          return;\n        }\n        _this.computeSizes();\n      });\n      _this.resizeObserver.observe(_this.containerRef);\n    };\n    // this is to prevent Safari on iOS >= 10 to zoom the page\n    _this.preventZoomSafari = function (e) {\n      return e.preventDefault();\n    };\n    _this.cleanEvents = function () {\n      if (!_this.currentDoc) return;\n      _this.currentDoc.removeEventListener('mousemove', _this.onMouseMove);\n      _this.currentDoc.removeEventListener('mouseup', _this.onDragStopped);\n      _this.currentDoc.removeEventListener('touchmove', _this.onTouchMove);\n      _this.currentDoc.removeEventListener('touchend', _this.onDragStopped);\n      _this.currentDoc.removeEventListener('gesturemove', _this.onGestureMove);\n      _this.currentDoc.removeEventListener('gestureend', _this.onGestureEnd);\n      _this.currentDoc.removeEventListener('scroll', _this.onScroll);\n    };\n    _this.clearScrollEvent = function () {\n      if (_this.containerRef) _this.containerRef.removeEventListener('wheel', _this.onWheel);\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n    };\n    _this.onMediaLoad = function () {\n      var cropSize = _this.computeSizes();\n      if (cropSize) {\n        _this.emitCropData();\n        _this.setInitialCrop(cropSize);\n      }\n      if (_this.props.onMediaLoaded) {\n        _this.props.onMediaLoaded(_this.mediaSize);\n      }\n    };\n    _this.setInitialCrop = function (cropSize) {\n      if (_this.props.initialCroppedAreaPercentages) {\n        var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n          crop = _a.crop,\n          zoom = _a.zoom;\n        _this.props.onCropChange(crop);\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      } else if (_this.props.initialCroppedAreaPixels) {\n        var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n          crop = _b.crop,\n          zoom = _b.zoom;\n        _this.props.onCropChange(crop);\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      }\n    };\n    _this.computeSizes = function () {\n      var _a, _b, _c, _d, _e, _f;\n      var mediaRef = _this.imageRef.current || _this.videoRef.current;\n      if (mediaRef && _this.containerRef) {\n        _this.containerRect = _this.containerRef.getBoundingClientRect();\n        _this.saveContainerPosition();\n        var containerAspect = _this.containerRect.width / _this.containerRect.height;\n        var naturalWidth = ((_a = _this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;\n        var naturalHeight = ((_c = _this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;\n        var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;\n        var mediaAspect = naturalWidth / naturalHeight;\n        // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n        // as the values they report are rounded. That will result in precision losses\n        // when calculating zoom. We use the fact that the media is positionned relative\n        // to the container. That allows us to use the container's dimensions\n        // and natural aspect ratio of the media to calculate accurate media size.\n        // However, for this to work, the container should not be rotated\n        var renderedMediaSize = void 0;\n        if (isMediaScaledDown) {\n          switch (_this.state.mediaObjectFit) {\n            default:\n            case 'contain':\n              renderedMediaSize = containerAspect > mediaAspect ? {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              } : {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n            case 'horizontal-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n            case 'vertical-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              };\n              break;\n          }\n        } else {\n          renderedMediaSize = {\n            width: mediaRef.offsetWidth,\n            height: mediaRef.offsetHeight\n          };\n        }\n        _this.mediaSize = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, renderedMediaSize), {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight\n        });\n        // set media size in the parent\n        if (_this.props.setMediaSize) {\n          _this.props.setMediaSize(_this.mediaSize);\n        }\n        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);\n        if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {\n          _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);\n        }\n        _this.setState({\n          cropSize: cropSize\n        }, _this.recomputeCropPosition);\n        // pass crop size to parent\n        if (_this.props.setCropSize) {\n          _this.props.setCropSize(cropSize);\n        }\n        return cropSize;\n      }\n    };\n    _this.saveContainerPosition = function () {\n      if (_this.containerRef) {\n        var bounds = _this.containerRef.getBoundingClientRect();\n        _this.containerPosition = {\n          x: bounds.left,\n          y: bounds.top\n        };\n      }\n    };\n    _this.onMouseDown = function (e) {\n      if (!_this.currentDoc) return;\n      e.preventDefault();\n      _this.currentDoc.addEventListener('mousemove', _this.onMouseMove);\n      _this.currentDoc.addEventListener('mouseup', _this.onDragStopped);\n      _this.saveContainerPosition();\n      _this.onDragStart(Cropper.getMousePoint(e));\n    };\n    _this.onMouseMove = function (e) {\n      return _this.onDrag(Cropper.getMousePoint(e));\n    };\n    _this.onScroll = function (e) {\n      if (!_this.currentDoc) return;\n      e.preventDefault();\n      _this.saveContainerPosition();\n    };\n    _this.onTouchStart = function (e) {\n      if (!_this.currentDoc) return;\n      _this.isTouching = true;\n      if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e)) {\n        return;\n      }\n      _this.currentDoc.addEventListener('touchmove', _this.onTouchMove, {\n        passive: false\n      }); // iOS 11 now defaults to passive: true\n      _this.currentDoc.addEventListener('touchend', _this.onDragStopped);\n      _this.saveContainerPosition();\n      if (e.touches.length === 2) {\n        _this.onPinchStart(e);\n      } else if (e.touches.length === 1) {\n        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n    _this.onTouchMove = function (e) {\n      // Prevent whole page from scrolling on iOS.\n      e.preventDefault();\n      if (e.touches.length === 2) {\n        _this.onPinchMove(e);\n      } else if (e.touches.length === 1) {\n        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n    _this.onGestureStart = function (e) {\n      if (!_this.currentDoc) return;\n      e.preventDefault();\n      _this.currentDoc.addEventListener('gesturechange', _this.onGestureMove);\n      _this.currentDoc.addEventListener('gestureend', _this.onGestureEnd);\n      _this.gestureZoomStart = _this.props.zoom;\n      _this.gestureRotationStart = _this.props.rotation;\n    };\n    _this.onGestureMove = function (e) {\n      e.preventDefault();\n      if (_this.isTouching) {\n        // this is to avoid conflict between gesture and touch events\n        return;\n      }\n      var point = Cropper.getMousePoint(e);\n      var newZoom = _this.gestureZoomStart - 1 + e.scale;\n      _this.setNewZoom(newZoom, point, {\n        shouldUpdatePosition: true\n      });\n      if (_this.props.onRotationChange) {\n        var newRotation = _this.gestureRotationStart + e.rotation;\n        _this.props.onRotationChange(newRotation);\n      }\n    };\n    _this.onGestureEnd = function (e) {\n      _this.cleanEvents();\n    };\n    _this.onDragStart = function (_a) {\n      var _b, _c;\n      var x = _a.x,\n        y = _a.y;\n      _this.dragStartPosition = {\n        x: x,\n        y: y\n      };\n      _this.dragStartCrop = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _this.props.crop);\n      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);\n    };\n    _this.onDrag = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      if (!_this.currentWindow) return;\n      if (_this.rafDragTimeout) _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);\n      _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(function () {\n        if (!_this.state.cropSize) return;\n        if (x === undefined || y === undefined) return;\n        var offsetX = x - _this.dragStartPosition.x;\n        var offsetY = y - _this.dragStartPosition.y;\n        var requestedPosition = {\n          x: _this.dragStartCrop.x + offsetX,\n          y: _this.dragStartCrop.y + offsetY\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;\n        _this.props.onCropChange(newPosition);\n      });\n    };\n    _this.onDragStopped = function () {\n      var _a, _b;\n      _this.isTouching = false;\n      _this.cleanEvents();\n      _this.emitCropData();\n      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    _this.onWheel = function (e) {\n      if (!_this.currentWindow) return;\n      if (_this.props.onWheelRequest && !_this.props.onWheelRequest(e)) {\n        return;\n      }\n      e.preventDefault();\n      var point = Cropper.getMousePoint(e);\n      var pixelY = normalize_wheel__WEBPACK_IMPORTED_MODULE_1___default()(e).pixelY;\n      var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;\n      _this.setNewZoom(newZoom, point, {\n        shouldUpdatePosition: true\n      });\n      if (!_this.state.hasWheelJustStarted) {\n        _this.setState({\n          hasWheelJustStarted: true\n        }, function () {\n          var _a, _b;\n          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n      _this.wheelTimer = _this.currentWindow.setTimeout(function () {\n        return _this.setState({\n          hasWheelJustStarted: false\n        }, function () {\n          var _a, _b;\n          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }, 250);\n    };\n    _this.getPointOnContainer = function (_a, containerTopLeft) {\n      var x = _a.x,\n        y = _a.y;\n      if (!_this.containerRect) {\n        throw new Error('The Cropper is not mounted');\n      }\n      return {\n        x: _this.containerRect.width / 2 - (x - containerTopLeft.x),\n        y: _this.containerRect.height / 2 - (y - containerTopLeft.y)\n      };\n    };\n    _this.getPointOnMedia = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      var _b = _this.props,\n        crop = _b.crop,\n        zoom = _b.zoom;\n      return {\n        x: (x + crop.x) / zoom,\n        y: (y + crop.y) / zoom\n      };\n    };\n    _this.setNewZoom = function (zoom, point, _a) {\n      var _b = _a === void 0 ? {} : _a,\n        _c = _b.shouldUpdatePosition,\n        shouldUpdatePosition = _c === void 0 ? true : _c;\n      if (!_this.state.cropSize || !_this.props.onZoomChange) return;\n      var newZoom = clamp(zoom, _this.props.minZoom, _this.props.maxZoom);\n      if (shouldUpdatePosition) {\n        var zoomPoint = _this.getPointOnContainer(point, _this.containerPosition);\n        var zoomTarget = _this.getPointOnMedia(zoomPoint);\n        var requestedPosition = {\n          x: zoomTarget.x * newZoom - zoomPoint.x,\n          y: zoomTarget.y * newZoom - zoomPoint.y\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;\n        _this.props.onCropChange(newPosition);\n      }\n      _this.props.onZoomChange(newZoom);\n    };\n    _this.getCropData = function () {\n      if (!_this.state.cropSize) {\n        return null;\n      }\n      // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n      return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);\n    };\n    _this.emitCropData = function () {\n      var cropData = _this.getCropData();\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n        croppedAreaPixels = cropData.croppedAreaPixels;\n      if (_this.props.onCropComplete) {\n        _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);\n      }\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n    _this.emitCropAreaChange = function () {\n      var cropData = _this.getCropData();\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n        croppedAreaPixels = cropData.croppedAreaPixels;\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n    _this.recomputeCropPosition = function () {\n      if (!_this.state.cropSize) return;\n      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n      _this.props.onCropChange(newPosition);\n      _this.emitCropData();\n    };\n    return _this;\n  }\n  Cropper.prototype.componentDidMount = function () {\n    if (!this.currentDoc || !this.currentWindow) return;\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument;\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView;\n      }\n      this.initResizeObserver();\n      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant\n      if (typeof window.ResizeObserver === 'undefined') {\n        this.currentWindow.addEventListener('resize', this.computeSizes);\n      }\n      this.props.zoomWithScroll && this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      });\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart);\n    }\n    this.currentDoc.addEventListener('scroll', this.onScroll);\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style');\n      this.styleRef.setAttribute('type', 'text/css');\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce);\n      }\n      this.styleRef.innerHTML = css_248z;\n      this.currentDoc.head.appendChild(this.styleRef);\n    }\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad();\n    }\n    // set image and video refs in the parent if the callbacks exist\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef);\n    }\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef);\n    }\n  };\n  Cropper.prototype.componentWillUnmount = function () {\n    var _a, _b;\n    if (!this.currentDoc || !this.currentWindow) return;\n    if (typeof window.ResizeObserver === 'undefined') {\n      this.currentWindow.removeEventListener('resize', this.computeSizes);\n    }\n    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);\n    }\n    if (this.styleRef) {\n      (_b = this.styleRef.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.styleRef);\n    }\n    this.cleanEvents();\n    this.props.zoomWithScroll && this.clearScrollEvent();\n  };\n  Cropper.prototype.componentDidUpdate = function (prevProps) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes();\n      this.recomputeCropPosition();\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes();\n    } else if (prevProps.objectFit !== this.props.objectFit) {\n      this.computeSizes();\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition();\n    } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {\n      this.computeSizes();\n    } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {\n      this.emitCropAreaChange();\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll ? this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      }) : this.clearScrollEvent();\n    }\n    if (prevProps.video !== this.props.video) {\n      (_j = this.videoRef.current) === null || _j === void 0 ? void 0 : _j.load();\n    }\n    var objectFit = this.getObjectFit();\n    if (objectFit !== this.state.mediaObjectFit) {\n      this.setState({\n        mediaObjectFit: objectFit\n      }, this.computeSizes);\n    }\n  };\n  Cropper.prototype.getAspect = function () {\n    var _a = this.props,\n      cropSize = _a.cropSize,\n      aspect = _a.aspect;\n    if (cropSize) {\n      return cropSize.width / cropSize.height;\n    }\n    return aspect;\n  };\n  Cropper.prototype.getObjectFit = function () {\n    var _a, _b, _c, _d;\n    if (this.props.objectFit === 'cover') {\n      var mediaRef = this.imageRef.current || this.videoRef.current;\n      if (mediaRef && this.containerRef) {\n        this.containerRect = this.containerRef.getBoundingClientRect();\n        var containerAspect = this.containerRect.width / this.containerRect.height;\n        var naturalWidth = ((_a = this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;\n        var naturalHeight = ((_c = this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;\n        var mediaAspect = naturalWidth / naturalHeight;\n        return mediaAspect < containerAspect ? 'horizontal-cover' : 'vertical-cover';\n      }\n      return 'horizontal-cover';\n    }\n    return this.props.objectFit;\n  };\n  Cropper.prototype.onPinchStart = function (e) {\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);\n    this.onDragStart(getCenter(pointA, pointB));\n  };\n  Cropper.prototype.onPinchMove = function (e) {\n    var _this = this;\n    if (!this.currentDoc || !this.currentWindow) return;\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    var center = getCenter(pointA, pointB);\n    this.onDrag(center);\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(function () {\n      var distance = getDistanceBetweenPoints(pointA, pointB);\n      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);\n      _this.setNewZoom(newZoom, center, {\n        shouldUpdatePosition: false\n      });\n      _this.lastPinchDistance = distance;\n      var rotation = getRotationBetweenPoints(pointA, pointB);\n      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);\n      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);\n      _this.lastPinchRotation = rotation;\n    });\n  };\n  Cropper.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      image = _a.image,\n      video = _a.video,\n      mediaProps = _a.mediaProps,\n      transform = _a.transform,\n      _b = _a.crop,\n      x = _b.x,\n      y = _b.y,\n      rotation = _a.rotation,\n      zoom = _a.zoom,\n      cropShape = _a.cropShape,\n      showGrid = _a.showGrid,\n      _c = _a.style,\n      containerStyle = _c.containerStyle,\n      cropAreaStyle = _c.cropAreaStyle,\n      mediaStyle = _c.mediaStyle,\n      _d = _a.classes,\n      containerClassName = _d.containerClassName,\n      cropAreaClassName = _d.cropAreaClassName,\n      mediaClassName = _d.mediaClassName;\n    var objectFit = this.state.mediaObjectFit;\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      onMouseDown: this.onMouseDown,\n      onTouchStart: this.onTouchStart,\n      ref: function ref(el) {\n        return _this.containerRef = el;\n      },\n      \"data-testid\": \"container\",\n      style: containerStyle,\n      className: classNames('reactEasyCrop_Container', containerClassName)\n    }, image ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      alt: \"\",\n      className: classNames('reactEasyCrop_Image', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', mediaClassName)\n    }, mediaProps, {\n      src: image,\n      ref: this.imageRef,\n      style: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, mediaStyle), {\n        transform: transform || \"translate(\".concat(x, \"px, \").concat(y, \"px) rotate(\").concat(rotation, \"deg) scale(\").concat(zoom, \")\")\n      }),\n      onLoad: this.onMediaLoad\n    })) : video && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"video\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      autoPlay: true,\n      loop: true,\n      muted: true,\n      className: classNames('reactEasyCrop_Video', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', mediaClassName)\n    }, mediaProps, {\n      ref: this.videoRef,\n      onLoadedMetadata: this.onMediaLoad,\n      style: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, mediaStyle), {\n        transform: transform || \"translate(\".concat(x, \"px, \").concat(y, \"px) rotate(\").concat(rotation, \"deg) scale(\").concat(zoom, \")\")\n      }),\n      controls: false\n    }), (Array.isArray(video) ? video : [{\n      src: video\n    }]).map(function (item) {\n      return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"source\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        key: item.src\n      }, item));\n    })), this.state.cropSize && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      style: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, cropAreaStyle), {\n        width: this.state.cropSize.width,\n        height: this.state.cropSize.height\n      }),\n      \"data-testid\": \"cropper\",\n      className: classNames('reactEasyCrop_CropArea', cropShape === 'round' && 'reactEasyCrop_CropAreaRound', showGrid && 'reactEasyCrop_CropAreaGrid', cropAreaClassName)\n    }));\n  };\n  Cropper.defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    objectFit: 'contain',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true\n  };\n  Cropper.getMousePoint = function (e) {\n    return {\n      x: Number(e.clientX),\n      y: Number(e.clientY)\n    };\n  };\n  Cropper.getTouchPoint = function (touch) {\n    return {\n      x: Number(touch.clientX),\n      y: Number(touch.clientY)\n    };\n  };\n  return Cropper;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n\n//# sourceMappingURL=index.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZWFzeS1jcm9wL2luZGV4Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0QztBQUNiO0FBQ2M7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFRLENBQUMsK0NBQVEsR0FBRztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDBDQUEwQyx1QkFBdUIsV0FBVyxZQUFZLGFBQWEsY0FBYyxxQkFBcUIsc0JBQXNCLHVCQUF1QixpQkFBaUIsa0JBQWtCLDRCQUE0Qix3QkFBd0IsR0FBRyxpREFBaUQsNEJBQTRCLDZFQUE2RSw0QkFBNEIsb0JBQW9CLHFCQUFxQixpQkFBaUIsdUJBQXVCLFdBQVcsY0FBYyxZQUFZLGFBQWEsR0FBRyxtQ0FBbUMsZ0JBQWdCLGlCQUFpQixHQUFHLGlDQUFpQyxnQkFBZ0IsaUJBQWlCLEdBQUcsNkJBQTZCLHVCQUF1QixjQUFjLGFBQWEscUNBQXFDLCtDQUErQywyQkFBMkIsNkJBQTZCLDhCQUE4QixxQkFBcUIsR0FBRyxrQ0FBa0MsdUJBQXVCLEdBQUcseUNBQXlDLGlCQUFpQiwyQkFBMkIsdUJBQXVCLCtDQUErQyxXQUFXLGNBQWMsaUJBQWlCLGtCQUFrQixrQkFBa0IscUJBQXFCLEdBQUcsd0NBQXdDLGlCQUFpQiwyQkFBMkIsdUJBQXVCLCtDQUErQyxnQkFBZ0IsbUJBQW1CLFlBQVksYUFBYSxtQkFBbUIsb0JBQW9CLEdBQUc7O0FBRXJpRDtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBZTtBQUNwQyxxQkFBcUIsNENBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFRLENBQUMsK0NBQVEsR0FBRztBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQVEsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssVUFBVSxnREFBbUIsUUFBUSwrQ0FBUTtBQUNsRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLCtDQUFRLENBQUMsK0NBQVEsR0FBRztBQUNqQztBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssY0FBYyxnREFBbUIsVUFBVSwrQ0FBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSwrQ0FBUSxDQUFDLCtDQUFRLEdBQUc7QUFDakM7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsYUFBYSxnREFBbUIsV0FBVywrQ0FBUTtBQUNuRDtBQUNBLE9BQU87QUFDUCxLQUFLLDJCQUEyQixnREFBbUI7QUFDbkQsYUFBYSwrQ0FBUSxDQUFDLCtDQUFRLEdBQUc7QUFDakM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGVBQWU7QUFDZixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyw0Q0FBZTs7QUFFNEY7QUFDN0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9lLXNob3AvLi9ub2RlX21vZHVsZXMvcmVhY3QtZWFzeS1jcm9wL2luZGV4Lm1vZHVsZS5qcz8yY2U5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbm9ybWFsaXplV2hlZWwgZnJvbSAnbm9ybWFsaXplLXdoZWVsJztcblxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGRpbWVuc2lvbiBvZiB0aGUgY3JvcCBhcmVhIGJhc2VkIG9uIG1lZGlhIHNpemUsXHJcbiAqIGFzcGVjdCByYXRpbyBhbmQgb3B0aW9uYWxseSByb3RhdGlvblxyXG4gKi9cbmZ1bmN0aW9uIGdldENyb3BTaXplKG1lZGlhV2lkdGgsIG1lZGlhSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBhc3BlY3QsIHJvdGF0aW9uKSB7XG4gIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcm90YXRpb24gPSAwO1xuICB9XG4gIHZhciBfYSA9IHJvdGF0ZVNpemUobWVkaWFXaWR0aCwgbWVkaWFIZWlnaHQsIHJvdGF0aW9uKSxcbiAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgdmFyIGZpdHRpbmdXaWR0aCA9IE1hdGgubWluKHdpZHRoLCBjb250YWluZXJXaWR0aCk7XG4gIHZhciBmaXR0aW5nSGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBjb250YWluZXJIZWlnaHQpO1xuICBpZiAoZml0dGluZ1dpZHRoID4gZml0dGluZ0hlaWdodCAqIGFzcGVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogZml0dGluZ0hlaWdodCAqIGFzcGVjdCxcbiAgICAgIGhlaWdodDogZml0dGluZ0hlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogZml0dGluZ1dpZHRoLFxuICAgIGhlaWdodDogZml0dGluZ1dpZHRoIC8gYXNwZWN0XG4gIH07XG59XG4vKipcclxuICogQ29tcHV0ZSBtZWRpYSB6b29tLlxyXG4gKiBXZSBmaXQgdGhlIG1lZGlhIGludG8gdGhlIGNvbnRhaW5lciB3aXRoIFwibWF4LXdpZHRoOiAxMDAlOyBtYXgtaGVpZ2h0OiAxMDAlO1wiXHJcbiAqL1xuZnVuY3Rpb24gZ2V0TWVkaWFab29tKG1lZGlhU2l6ZSkge1xuICAvLyBUYWtlIHRoZSBheGlzIHdpdGggbW9yZSBwaXhlbHMgdG8gaW1wcm92ZSBhY2N1cmFjeVxuICByZXR1cm4gbWVkaWFTaXplLndpZHRoID4gbWVkaWFTaXplLmhlaWdodCA/IG1lZGlhU2l6ZS53aWR0aCAvIG1lZGlhU2l6ZS5uYXR1cmFsV2lkdGggOiBtZWRpYVNpemUuaGVpZ2h0IC8gbWVkaWFTaXplLm5hdHVyYWxIZWlnaHQ7XG59XG4vKipcclxuICogRW5zdXJlIGEgbmV3IG1lZGlhIHBvc2l0aW9uIHN0YXlzIGluIHRoZSBjcm9wIGFyZWEuXHJcbiAqL1xuZnVuY3Rpb24gcmVzdHJpY3RQb3NpdGlvbihwb3NpdGlvbiwgbWVkaWFTaXplLCBjcm9wU2l6ZSwgem9vbSwgcm90YXRpb24pIHtcbiAgaWYgKHJvdGF0aW9uID09PSB2b2lkIDApIHtcbiAgICByb3RhdGlvbiA9IDA7XG4gIH1cbiAgdmFyIF9hID0gcm90YXRlU2l6ZShtZWRpYVNpemUud2lkdGgsIG1lZGlhU2l6ZS5oZWlnaHQsIHJvdGF0aW9uKSxcbiAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICB4OiByZXN0cmljdFBvc2l0aW9uQ29vcmQocG9zaXRpb24ueCwgd2lkdGgsIGNyb3BTaXplLndpZHRoLCB6b29tKSxcbiAgICB5OiByZXN0cmljdFBvc2l0aW9uQ29vcmQocG9zaXRpb24ueSwgaGVpZ2h0LCBjcm9wU2l6ZS5oZWlnaHQsIHpvb20pXG4gIH07XG59XG5mdW5jdGlvbiByZXN0cmljdFBvc2l0aW9uQ29vcmQocG9zaXRpb24sIG1lZGlhU2l6ZSwgY3JvcFNpemUsIHpvb20pIHtcbiAgdmFyIG1heFBvc2l0aW9uID0gbWVkaWFTaXplICogem9vbSAvIDIgLSBjcm9wU2l6ZSAvIDI7XG4gIHJldHVybiBjbGFtcChwb3NpdGlvbiwgLW1heFBvc2l0aW9uLCBtYXhQb3NpdGlvbik7XG59XG5mdW5jdGlvbiBnZXREaXN0YW5jZUJldHdlZW5Qb2ludHMocG9pbnRBLCBwb2ludEIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludEEueSAtIHBvaW50Qi55LCAyKSArIE1hdGgucG93KHBvaW50QS54IC0gcG9pbnRCLngsIDIpKTtcbn1cbmZ1bmN0aW9uIGdldFJvdGF0aW9uQmV0d2VlblBvaW50cyhwb2ludEEsIHBvaW50Qikge1xuICByZXR1cm4gTWF0aC5hdGFuMihwb2ludEIueSAtIHBvaW50QS55LCBwb2ludEIueCAtIHBvaW50QS54KSAqIDE4MCAvIE1hdGguUEk7XG59XG4vKipcclxuICogQ29tcHV0ZSB0aGUgb3V0cHV0IGNyb3BwZWQgYXJlYSBvZiB0aGUgbWVkaWEgaW4gcGVyY2VudGFnZXMgYW5kIHBpeGVscy5cclxuICogeC95IGFyZSB0aGUgdG9wLWxlZnQgY29vcmRpbmF0ZXMgb24gdGhlIHNyYyBtZWRpYVxyXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVDcm9wcGVkQXJlYShjcm9wLCBtZWRpYVNpemUsIGNyb3BTaXplLCBhc3BlY3QsIHpvb20sIHJvdGF0aW9uLCByZXN0cmljdFBvc2l0aW9uKSB7XG4gIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcm90YXRpb24gPSAwO1xuICB9XG4gIGlmIChyZXN0cmljdFBvc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICByZXN0cmljdFBvc2l0aW9uID0gdHJ1ZTtcbiAgfVxuICAvLyBpZiB0aGUgbWVkaWEgaXMgcm90YXRlZCBieSB0aGUgdXNlciwgd2UgY2Fubm90IGxpbWl0IHRoZSBwb3NpdGlvbiBhbnltb3JlXG4gIC8vIGFzIGl0IG1pZ2h0IG5lZWQgdG8gYmUgbmVnYXRpdmUuXG4gIHZhciBsaW1pdEFyZWFGbiA9IHJlc3RyaWN0UG9zaXRpb24gPyBsaW1pdEFyZWEgOiBub09wO1xuICB2YXIgbWVkaWFCQm94U2l6ZSA9IHJvdGF0ZVNpemUobWVkaWFTaXplLndpZHRoLCBtZWRpYVNpemUuaGVpZ2h0LCByb3RhdGlvbik7XG4gIHZhciBtZWRpYU5hdHVyYWxCQm94U2l6ZSA9IHJvdGF0ZVNpemUobWVkaWFTaXplLm5hdHVyYWxXaWR0aCwgbWVkaWFTaXplLm5hdHVyYWxIZWlnaHQsIHJvdGF0aW9uKTtcbiAgLy8gY2FsY3VsYXRlIHRoZSBjcm9wIGFyZWEgaW4gcGVyY2VudGFnZXNcbiAgLy8gaW4gdGhlIHJvdGF0ZWQgc3BhY2VcbiAgdmFyIGNyb3BwZWRBcmVhUGVyY2VudGFnZXMgPSB7XG4gICAgeDogbGltaXRBcmVhRm4oMTAwLCAoKG1lZGlhQkJveFNpemUud2lkdGggLSBjcm9wU2l6ZS53aWR0aCAvIHpvb20pIC8gMiAtIGNyb3AueCAvIHpvb20pIC8gbWVkaWFCQm94U2l6ZS53aWR0aCAqIDEwMCksXG4gICAgeTogbGltaXRBcmVhRm4oMTAwLCAoKG1lZGlhQkJveFNpemUuaGVpZ2h0IC0gY3JvcFNpemUuaGVpZ2h0IC8gem9vbSkgLyAyIC0gY3JvcC55IC8gem9vbSkgLyBtZWRpYUJCb3hTaXplLmhlaWdodCAqIDEwMCksXG4gICAgd2lkdGg6IGxpbWl0QXJlYUZuKDEwMCwgY3JvcFNpemUud2lkdGggLyBtZWRpYUJCb3hTaXplLndpZHRoICogMTAwIC8gem9vbSksXG4gICAgaGVpZ2h0OiBsaW1pdEFyZWFGbigxMDAsIGNyb3BTaXplLmhlaWdodCAvIG1lZGlhQkJveFNpemUuaGVpZ2h0ICogMTAwIC8gem9vbSlcbiAgfTtcbiAgLy8gd2UgY29tcHV0ZSB0aGUgcGl4ZWxzIHNpemUgbmFpdmVseVxuICB2YXIgd2lkdGhJblBpeGVscyA9IE1hdGgucm91bmQobGltaXRBcmVhRm4obWVkaWFOYXR1cmFsQkJveFNpemUud2lkdGgsIGNyb3BwZWRBcmVhUGVyY2VudGFnZXMud2lkdGggKiBtZWRpYU5hdHVyYWxCQm94U2l6ZS53aWR0aCAvIDEwMCkpO1xuICB2YXIgaGVpZ2h0SW5QaXhlbHMgPSBNYXRoLnJvdW5kKGxpbWl0QXJlYUZuKG1lZGlhTmF0dXJhbEJCb3hTaXplLmhlaWdodCwgY3JvcHBlZEFyZWFQZXJjZW50YWdlcy5oZWlnaHQgKiBtZWRpYU5hdHVyYWxCQm94U2l6ZS5oZWlnaHQgLyAxMDApKTtcbiAgdmFyIGlzSW1nV2lkZXJUaGFuSGlnaCA9IG1lZGlhTmF0dXJhbEJCb3hTaXplLndpZHRoID49IG1lZGlhTmF0dXJhbEJCb3hTaXplLmhlaWdodCAqIGFzcGVjdDtcbiAgLy8gdGhlbiB3ZSBlbnN1cmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgZXhhY3RseSBtYXRjaCB0aGUgYXNwZWN0ICh0byBhdm9pZCByb3VuZGluZyBhcHByb3hpbWF0aW9ucylcbiAgLy8gaWYgdGhlIG1lZGlhIGlzIHdpZGVyIHRoYW4gaGlnaCwgd2hlbiB6b29tIGlzIDAsIHRoZSBjcm9wIGhlaWdodCB3aWxsIGJlIGVxdWFscyB0byBpbWFnZSBoZWlnaHRcbiAgLy8gdGh1cyB3ZSB3YW50IHRvIGNvbXB1dGUgdGhlIHdpZHRoIGZyb20gdGhlIGhlaWdodCBhbmQgYXNwZWN0IGZvciBhY2N1cmFjeS5cbiAgLy8gT3RoZXJ3aXNlLCB3ZSBjb21wdXRlIHRoZSBoZWlnaHQgZnJvbSB3aWR0aCBhbmQgYXNwZWN0LlxuICB2YXIgc2l6ZVBpeGVscyA9IGlzSW1nV2lkZXJUaGFuSGlnaCA/IHtcbiAgICB3aWR0aDogTWF0aC5yb3VuZChoZWlnaHRJblBpeGVscyAqIGFzcGVjdCksXG4gICAgaGVpZ2h0OiBoZWlnaHRJblBpeGVsc1xuICB9IDoge1xuICAgIHdpZHRoOiB3aWR0aEluUGl4ZWxzLFxuICAgIGhlaWdodDogTWF0aC5yb3VuZCh3aWR0aEluUGl4ZWxzIC8gYXNwZWN0KVxuICB9O1xuICB2YXIgY3JvcHBlZEFyZWFQaXhlbHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2l6ZVBpeGVscyksIHtcbiAgICB4OiBNYXRoLnJvdW5kKGxpbWl0QXJlYUZuKG1lZGlhTmF0dXJhbEJCb3hTaXplLndpZHRoIC0gc2l6ZVBpeGVscy53aWR0aCwgY3JvcHBlZEFyZWFQZXJjZW50YWdlcy54ICogbWVkaWFOYXR1cmFsQkJveFNpemUud2lkdGggLyAxMDApKSxcbiAgICB5OiBNYXRoLnJvdW5kKGxpbWl0QXJlYUZuKG1lZGlhTmF0dXJhbEJCb3hTaXplLmhlaWdodCAtIHNpemVQaXhlbHMuaGVpZ2h0LCBjcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLnkgKiBtZWRpYU5hdHVyYWxCQm94U2l6ZS5oZWlnaHQgLyAxMDApKVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjcm9wcGVkQXJlYVBlcmNlbnRhZ2VzOiBjcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLFxuICAgIGNyb3BwZWRBcmVhUGl4ZWxzOiBjcm9wcGVkQXJlYVBpeGVsc1xuICB9O1xufVxuLyoqXHJcbiAqIEVuc3VyZSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYmV0d2VlbiAwIGFuZCBtYXhcclxuICovXG5mdW5jdGlvbiBsaW1pdEFyZWEobWF4LCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gbm9PcChfbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG4vKipcclxuICogQ29tcHV0ZSBjcm9wIGFuZCB6b29tIGZyb20gdGhlIGNyb3BwZWRBcmVhUGVyY2VudGFnZXMuXHJcbiAqL1xuZnVuY3Rpb24gZ2V0SW5pdGlhbENyb3BGcm9tQ3JvcHBlZEFyZWFQZXJjZW50YWdlcyhjcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLCBtZWRpYVNpemUsIHJvdGF0aW9uLCBjcm9wU2l6ZSwgbWluWm9vbSwgbWF4Wm9vbSkge1xuICB2YXIgbWVkaWFCQm94U2l6ZSA9IHJvdGF0ZVNpemUobWVkaWFTaXplLndpZHRoLCBtZWRpYVNpemUuaGVpZ2h0LCByb3RhdGlvbik7XG4gIC8vIFRoaXMgaXMgdGhlIGludmVyc2UgcHJvY2VzcyBvZiBjb21wdXRlQ3JvcHBlZEFyZWFcbiAgdmFyIHpvb20gPSBjbGFtcChjcm9wU2l6ZS53aWR0aCAvIG1lZGlhQkJveFNpemUud2lkdGggKiAoMTAwIC8gY3JvcHBlZEFyZWFQZXJjZW50YWdlcy53aWR0aCksIG1pblpvb20sIG1heFpvb20pO1xuICB2YXIgY3JvcCA9IHtcbiAgICB4OiB6b29tICogbWVkaWFCQm94U2l6ZS53aWR0aCAvIDIgLSBjcm9wU2l6ZS53aWR0aCAvIDIgLSBtZWRpYUJCb3hTaXplLndpZHRoICogem9vbSAqIChjcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLnggLyAxMDApLFxuICAgIHk6IHpvb20gKiBtZWRpYUJCb3hTaXplLmhlaWdodCAvIDIgLSBjcm9wU2l6ZS5oZWlnaHQgLyAyIC0gbWVkaWFCQm94U2l6ZS5oZWlnaHQgKiB6b29tICogKGNyb3BwZWRBcmVhUGVyY2VudGFnZXMueSAvIDEwMClcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjcm9wOiBjcm9wLFxuICAgIHpvb206IHpvb21cbiAgfTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlIHpvb20gZnJvbSB0aGUgY3JvcHBlZEFyZWFQaXhlbHNcclxuICovXG5mdW5jdGlvbiBnZXRab29tRnJvbUNyb3BwZWRBcmVhUGl4ZWxzKGNyb3BwZWRBcmVhUGl4ZWxzLCBtZWRpYVNpemUsIGNyb3BTaXplKSB7XG4gIHZhciBtZWRpYVpvb20gPSBnZXRNZWRpYVpvb20obWVkaWFTaXplKTtcbiAgcmV0dXJuIGNyb3BTaXplLmhlaWdodCA+IGNyb3BTaXplLndpZHRoID8gY3JvcFNpemUuaGVpZ2h0IC8gKGNyb3BwZWRBcmVhUGl4ZWxzLmhlaWdodCAqIG1lZGlhWm9vbSkgOiBjcm9wU2l6ZS53aWR0aCAvIChjcm9wcGVkQXJlYVBpeGVscy53aWR0aCAqIG1lZGlhWm9vbSk7XG59XG4vKipcclxuICogQ29tcHV0ZSBjcm9wIGFuZCB6b29tIGZyb20gdGhlIGNyb3BwZWRBcmVhUGl4ZWxzXHJcbiAqL1xuZnVuY3Rpb24gZ2V0SW5pdGlhbENyb3BGcm9tQ3JvcHBlZEFyZWFQaXhlbHMoY3JvcHBlZEFyZWFQaXhlbHMsIG1lZGlhU2l6ZSwgcm90YXRpb24sIGNyb3BTaXplLCBtaW5ab29tLCBtYXhab29tKSB7XG4gIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcm90YXRpb24gPSAwO1xuICB9XG4gIHZhciBtZWRpYU5hdHVyYWxCQm94U2l6ZSA9IHJvdGF0ZVNpemUobWVkaWFTaXplLm5hdHVyYWxXaWR0aCwgbWVkaWFTaXplLm5hdHVyYWxIZWlnaHQsIHJvdGF0aW9uKTtcbiAgdmFyIHpvb20gPSBjbGFtcChnZXRab29tRnJvbUNyb3BwZWRBcmVhUGl4ZWxzKGNyb3BwZWRBcmVhUGl4ZWxzLCBtZWRpYVNpemUsIGNyb3BTaXplKSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gIHZhciBjcm9wWm9vbSA9IGNyb3BTaXplLmhlaWdodCA+IGNyb3BTaXplLndpZHRoID8gY3JvcFNpemUuaGVpZ2h0IC8gY3JvcHBlZEFyZWFQaXhlbHMuaGVpZ2h0IDogY3JvcFNpemUud2lkdGggLyBjcm9wcGVkQXJlYVBpeGVscy53aWR0aDtcbiAgdmFyIGNyb3AgPSB7XG4gICAgeDogKChtZWRpYU5hdHVyYWxCQm94U2l6ZS53aWR0aCAtIGNyb3BwZWRBcmVhUGl4ZWxzLndpZHRoKSAvIDIgLSBjcm9wcGVkQXJlYVBpeGVscy54KSAqIGNyb3Bab29tLFxuICAgIHk6ICgobWVkaWFOYXR1cmFsQkJveFNpemUuaGVpZ2h0IC0gY3JvcHBlZEFyZWFQaXhlbHMuaGVpZ2h0KSAvIDIgLSBjcm9wcGVkQXJlYVBpeGVscy55KSAqIGNyb3Bab29tXG4gIH07XG4gIHJldHVybiB7XG4gICAgY3JvcDogY3JvcCxcbiAgICB6b29tOiB6b29tXG4gIH07XG59XG4vKipcclxuICogUmV0dXJuIHRoZSBwb2ludCB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgcG9pbnQgYSBhbmQgYlxyXG4gKi9cbmZ1bmN0aW9uIGdldENlbnRlcihhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgeDogKGIueCArIGEueCkgLyAyLFxuICAgIHk6IChiLnkgKyBhLnkpIC8gMlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmFkaWFuQW5nbGUoZGVncmVlVmFsdWUpIHtcbiAgcmV0dXJuIGRlZ3JlZVZhbHVlICogTWF0aC5QSSAvIDE4MDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBuZXcgYm91bmRpbmcgYXJlYSBvZiBhIHJvdGF0ZWQgcmVjdGFuZ2xlLlxyXG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVNpemUod2lkdGgsIGhlaWdodCwgcm90YXRpb24pIHtcbiAgdmFyIHJvdFJhZCA9IGdldFJhZGlhbkFuZ2xlKHJvdGF0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogTWF0aC5hYnMoTWF0aC5jb3Mocm90UmFkKSAqIHdpZHRoKSArIE1hdGguYWJzKE1hdGguc2luKHJvdFJhZCkgKiBoZWlnaHQpLFxuICAgIGhlaWdodDogTWF0aC5hYnMoTWF0aC5zaW4ocm90UmFkKSAqIHdpZHRoKSArIE1hdGguYWJzKE1hdGguY29zKHJvdFJhZCkgKiBoZWlnaHQpXG4gIH07XG59XG4vKipcclxuICogQ2xhbXAgdmFsdWUgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG4gKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG4vKipcclxuICogQ29tYmluZSBtdWx0aXBsZSBjbGFzcyBuYW1lcyBpbnRvIGEgc2luZ2xlIHN0cmluZy5cclxuICovXG5mdW5jdGlvbiBjbGFzc05hbWVzKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICByZXR1cm4gYXJncy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSkuam9pbignICcpLnRyaW0oKTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCIucmVhY3RFYXN5Q3JvcF9Db250YWluZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbiAgY3Vyc29yOiBtb3ZlO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLnJlYWN0RWFzeUNyb3BfSW1hZ2UsXFxuLnJlYWN0RWFzeUNyb3BfVmlkZW8ge1xcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTsgLyogdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZXMgYW5kIHByZXZlbnQgcGFpbnRpbmcgaXNzdWVzIG9uIGlPUyBDaHJvbWUgKi9cXG59XFxuXFxuLnJlYWN0RWFzeUNyb3BfQ29udGFpbiB7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbn1cXG4ucmVhY3RFYXN5Q3JvcF9Db3Zlcl9Ib3Jpem9udGFsIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG4ucmVhY3RFYXN5Q3JvcF9Db3Zlcl9WZXJ0aWNhbCB7XFxuICB3aWR0aDogYXV0bztcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnJlYWN0RWFzeUNyb3BfQ3JvcEFyZWEge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogNTAlO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3gtc2hhZG93OiAwIDAgMCA5OTk5ZW07XFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUpO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnJlYWN0RWFzeUNyb3BfQ3JvcEFyZWFSb3VuZCB7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxufVxcblxcbi5yZWFjdEVhc3lDcm9wX0Nyb3BBcmVhR3JpZDo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICcgJztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxuICB0b3A6IDA7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAzMy4zMyU7XFxuICByaWdodDogMzMuMzMlO1xcbiAgYm9yZGVyLXRvcDogMDtcXG4gIGJvcmRlci1ib3R0b206IDA7XFxufVxcblxcbi5yZWFjdEVhc3lDcm9wX0Nyb3BBcmVhR3JpZDo6YWZ0ZXIge1xcbiAgY29udGVudDogJyAnO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIHRvcDogMzMuMzMlO1xcbiAgYm90dG9tOiAzMy4zMyU7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3JkZXItbGVmdDogMDtcXG4gIGJvcmRlci1yaWdodDogMDtcXG59XFxuXCI7XG5cbnZhciBNSU5fWk9PTSA9IDE7XG52YXIgTUFYX1pPT00gPSAzO1xudmFyIENyb3BwZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ3JvcHBlciwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQ3JvcHBlcigpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5pbWFnZVJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIF90aGlzLnZpZGVvUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMuY29udGFpbmVyUG9zaXRpb24gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgX3RoaXMuY29udGFpbmVyUmVmID0gbnVsbDtcbiAgICBfdGhpcy5zdHlsZVJlZiA9IG51bGw7XG4gICAgX3RoaXMuY29udGFpbmVyUmVjdCA9IG51bGw7XG4gICAgX3RoaXMubWVkaWFTaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBuYXR1cmFsV2lkdGg6IDAsXG4gICAgICBuYXR1cmFsSGVpZ2h0OiAwXG4gICAgfTtcbiAgICBfdGhpcy5kcmFnU3RhcnRQb3NpdGlvbiA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBfdGhpcy5kcmFnU3RhcnRDcm9wID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIF90aGlzLmdlc3R1cmVab29tU3RhcnQgPSAwO1xuICAgIF90aGlzLmdlc3R1cmVSb3RhdGlvblN0YXJ0ID0gMDtcbiAgICBfdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XG4gICAgX3RoaXMubGFzdFBpbmNoRGlzdGFuY2UgPSAwO1xuICAgIF90aGlzLmxhc3RQaW5jaFJvdGF0aW9uID0gMDtcbiAgICBfdGhpcy5yYWZEcmFnVGltZW91dCA9IG51bGw7XG4gICAgX3RoaXMucmFmUGluY2hUaW1lb3V0ID0gbnVsbDtcbiAgICBfdGhpcy53aGVlbFRpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5jdXJyZW50RG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbiAgICBfdGhpcy5jdXJyZW50V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xuICAgIF90aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNyb3BTaXplOiBudWxsLFxuICAgICAgaGFzV2hlZWxKdXN0U3RhcnRlZDogZmFsc2UsXG4gICAgICBtZWRpYU9iamVjdEZpdDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBfdGhpcy5pbml0UmVzaXplT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcgfHwgIV90aGlzLmNvbnRhaW5lclJlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXNGaXJzdFJlc2l6ZSA9IHRydWU7XG4gICAgICBfdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGlzRmlyc3RSZXNpemUpIHtcbiAgICAgICAgICBpc0ZpcnN0UmVzaXplID0gZmFsc2U7IC8vIG9ic2VydmUoKSBpcyBjYWxsZWQgb24gbW91bnQsIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIHJlY29tcHV0ZSBvbiBtb3VudFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb21wdXRlU2l6ZXMoKTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShfdGhpcy5jb250YWluZXJSZWYpO1xuICAgIH07XG4gICAgLy8gdGhpcyBpcyB0byBwcmV2ZW50IFNhZmFyaSBvbiBpT1MgPj0gMTAgdG8gem9vbSB0aGUgcGFnZVxuICAgIF90aGlzLnByZXZlbnRab29tU2FmYXJpID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBfdGhpcy5jbGVhbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuY3VycmVudERvYykgcmV0dXJuO1xuICAgICAgX3RoaXMuY3VycmVudERvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICBfdGhpcy5jdXJyZW50RG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdGhpcy5vbkRyYWdTdG9wcGVkKTtcbiAgICAgIF90aGlzLmN1cnJlbnREb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3RoaXMub25Ub3VjaE1vdmUpO1xuICAgICAgX3RoaXMuY3VycmVudERvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLm9uRHJhZ1N0b3BwZWQpO1xuICAgICAgX3RoaXMuY3VycmVudERvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdnZXN0dXJlbW92ZScsIF90aGlzLm9uR2VzdHVyZU1vdmUpO1xuICAgICAgX3RoaXMuY3VycmVudERvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdnZXN0dXJlZW5kJywgX3RoaXMub25HZXN0dXJlRW5kKTtcbiAgICAgIF90aGlzLmN1cnJlbnREb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMub25TY3JvbGwpO1xuICAgIH07XG4gICAgX3RoaXMuY2xlYXJTY3JvbGxFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5jb250YWluZXJSZWYpIF90aGlzLmNvbnRhaW5lclJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIF90aGlzLm9uV2hlZWwpO1xuICAgICAgaWYgKF90aGlzLndoZWVsVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLndoZWVsVGltZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3RoaXMub25NZWRpYUxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3JvcFNpemUgPSBfdGhpcy5jb21wdXRlU2l6ZXMoKTtcbiAgICAgIGlmIChjcm9wU2l6ZSkge1xuICAgICAgICBfdGhpcy5lbWl0Q3JvcERhdGEoKTtcbiAgICAgICAgX3RoaXMuc2V0SW5pdGlhbENyb3AoY3JvcFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uTWVkaWFMb2FkZWQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25NZWRpYUxvYWRlZChfdGhpcy5tZWRpYVNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3RoaXMuc2V0SW5pdGlhbENyb3AgPSBmdW5jdGlvbiAoY3JvcFNpemUpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5pbml0aWFsQ3JvcHBlZEFyZWFQZXJjZW50YWdlcykge1xuICAgICAgICB2YXIgX2EgPSBnZXRJbml0aWFsQ3JvcEZyb21Dcm9wcGVkQXJlYVBlcmNlbnRhZ2VzKF90aGlzLnByb3BzLmluaXRpYWxDcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLCBfdGhpcy5tZWRpYVNpemUsIF90aGlzLnByb3BzLnJvdGF0aW9uLCBjcm9wU2l6ZSwgX3RoaXMucHJvcHMubWluWm9vbSwgX3RoaXMucHJvcHMubWF4Wm9vbSksXG4gICAgICAgICAgY3JvcCA9IF9hLmNyb3AsXG4gICAgICAgICAgem9vbSA9IF9hLnpvb207XG4gICAgICAgIF90aGlzLnByb3BzLm9uQ3JvcENoYW5nZShjcm9wKTtcbiAgICAgICAgX3RoaXMucHJvcHMub25ab29tQ2hhbmdlICYmIF90aGlzLnByb3BzLm9uWm9vbUNoYW5nZSh6b29tKTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMucHJvcHMuaW5pdGlhbENyb3BwZWRBcmVhUGl4ZWxzKSB7XG4gICAgICAgIHZhciBfYiA9IGdldEluaXRpYWxDcm9wRnJvbUNyb3BwZWRBcmVhUGl4ZWxzKF90aGlzLnByb3BzLmluaXRpYWxDcm9wcGVkQXJlYVBpeGVscywgX3RoaXMubWVkaWFTaXplLCBfdGhpcy5wcm9wcy5yb3RhdGlvbiwgY3JvcFNpemUsIF90aGlzLnByb3BzLm1pblpvb20sIF90aGlzLnByb3BzLm1heFpvb20pLFxuICAgICAgICAgIGNyb3AgPSBfYi5jcm9wLFxuICAgICAgICAgIHpvb20gPSBfYi56b29tO1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNyb3BDaGFuZ2UoY3JvcCk7XG4gICAgICAgIF90aGlzLnByb3BzLm9uWm9vbUNoYW5nZSAmJiBfdGhpcy5wcm9wcy5vblpvb21DaGFuZ2Uoem9vbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfdGhpcy5jb21wdXRlU2l6ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIHZhciBtZWRpYVJlZiA9IF90aGlzLmltYWdlUmVmLmN1cnJlbnQgfHwgX3RoaXMudmlkZW9SZWYuY3VycmVudDtcbiAgICAgIGlmIChtZWRpYVJlZiAmJiBfdGhpcy5jb250YWluZXJSZWYpIHtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyUmVjdCA9IF90aGlzLmNvbnRhaW5lclJlZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgX3RoaXMuc2F2ZUNvbnRhaW5lclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBjb250YWluZXJBc3BlY3QgPSBfdGhpcy5jb250YWluZXJSZWN0LndpZHRoIC8gX3RoaXMuY29udGFpbmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciBuYXR1cmFsV2lkdGggPSAoKF9hID0gX3RoaXMuaW1hZ2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hdHVyYWxXaWR0aCkgfHwgKChfYiA9IF90aGlzLnZpZGVvUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aWRlb1dpZHRoKSB8fCAwO1xuICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9ICgoX2MgPSBfdGhpcy5pbWFnZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubmF0dXJhbEhlaWdodCkgfHwgKChfZCA9IF90aGlzLnZpZGVvUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52aWRlb0hlaWdodCkgfHwgMDtcbiAgICAgICAgdmFyIGlzTWVkaWFTY2FsZWREb3duID0gbWVkaWFSZWYub2Zmc2V0V2lkdGggPCBuYXR1cmFsV2lkdGggfHwgbWVkaWFSZWYub2Zmc2V0SGVpZ2h0IDwgbmF0dXJhbEhlaWdodDtcbiAgICAgICAgdmFyIG1lZGlhQXNwZWN0ID0gbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodDtcbiAgICAgICAgLy8gV2UgZG8gbm90IHJlbHkgb24gdGhlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpZiB0aGUgbWVkaWEgaXMgc2NhbGVkIGRvd25cbiAgICAgICAgLy8gYXMgdGhlIHZhbHVlcyB0aGV5IHJlcG9ydCBhcmUgcm91bmRlZC4gVGhhdCB3aWxsIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zc2VzXG4gICAgICAgIC8vIHdoZW4gY2FsY3VsYXRpbmcgem9vbS4gV2UgdXNlIHRoZSBmYWN0IHRoYXQgdGhlIG1lZGlhIGlzIHBvc2l0aW9ubmVkIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBjb250YWluZXIuIFRoYXQgYWxsb3dzIHVzIHRvIHVzZSB0aGUgY29udGFpbmVyJ3MgZGltZW5zaW9uc1xuICAgICAgICAvLyBhbmQgbmF0dXJhbCBhc3BlY3QgcmF0aW8gb2YgdGhlIG1lZGlhIHRvIGNhbGN1bGF0ZSBhY2N1cmF0ZSBtZWRpYSBzaXplLlxuICAgICAgICAvLyBIb3dldmVyLCBmb3IgdGhpcyB0byB3b3JrLCB0aGUgY29udGFpbmVyIHNob3VsZCBub3QgYmUgcm90YXRlZFxuICAgICAgICB2YXIgcmVuZGVyZWRNZWRpYVNpemUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChpc01lZGlhU2NhbGVkRG93bikge1xuICAgICAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdGUubWVkaWFPYmplY3RGaXQpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlICdjb250YWluJzpcbiAgICAgICAgICAgICAgcmVuZGVyZWRNZWRpYVNpemUgPSBjb250YWluZXJBc3BlY3QgPiBtZWRpYUFzcGVjdCA/IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogX3RoaXMuY29udGFpbmVyUmVjdC5oZWlnaHQgKiBtZWRpYUFzcGVjdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IF90aGlzLmNvbnRhaW5lclJlY3QuaGVpZ2h0XG4gICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLmNvbnRhaW5lclJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5jb250YWluZXJSZWN0LndpZHRoIC8gbWVkaWFBc3BlY3RcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3Jpem9udGFsLWNvdmVyJzpcbiAgICAgICAgICAgICAgcmVuZGVyZWRNZWRpYVNpemUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLmNvbnRhaW5lclJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5jb250YWluZXJSZWN0LndpZHRoIC8gbWVkaWFBc3BlY3RcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2ZXJ0aWNhbC1jb3Zlcic6XG4gICAgICAgICAgICAgIHJlbmRlcmVkTWVkaWFTaXplID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBfdGhpcy5jb250YWluZXJSZWN0LmhlaWdodCAqIG1lZGlhQXNwZWN0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogX3RoaXMuY29udGFpbmVyUmVjdC5oZWlnaHRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVkTWVkaWFTaXplID0ge1xuICAgICAgICAgICAgd2lkdGg6IG1lZGlhUmVmLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBtZWRpYVJlZi5vZmZzZXRIZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm1lZGlhU2l6ZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZW5kZXJlZE1lZGlhU2l6ZSksIHtcbiAgICAgICAgICBuYXR1cmFsV2lkdGg6IG5hdHVyYWxXaWR0aCxcbiAgICAgICAgICBuYXR1cmFsSGVpZ2h0OiBuYXR1cmFsSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzZXQgbWVkaWEgc2l6ZSBpbiB0aGUgcGFyZW50XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZXRNZWRpYVNpemUpIHtcbiAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRNZWRpYVNpemUoX3RoaXMubWVkaWFTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3JvcFNpemUgPSBfdGhpcy5wcm9wcy5jcm9wU2l6ZSA/IF90aGlzLnByb3BzLmNyb3BTaXplIDogZ2V0Q3JvcFNpemUoX3RoaXMubWVkaWFTaXplLndpZHRoLCBfdGhpcy5tZWRpYVNpemUuaGVpZ2h0LCBfdGhpcy5jb250YWluZXJSZWN0LndpZHRoLCBfdGhpcy5jb250YWluZXJSZWN0LmhlaWdodCwgX3RoaXMucHJvcHMuYXNwZWN0LCBfdGhpcy5wcm9wcy5yb3RhdGlvbik7XG4gICAgICAgIGlmICgoKF9lID0gX3RoaXMuc3RhdGUuY3JvcFNpemUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5oZWlnaHQpICE9PSBjcm9wU2l6ZS5oZWlnaHQgfHwgKChfZiA9IF90aGlzLnN0YXRlLmNyb3BTaXplKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yud2lkdGgpICE9PSBjcm9wU2l6ZS53aWR0aCkge1xuICAgICAgICAgIF90aGlzLnByb3BzLm9uQ3JvcFNpemVDaGFuZ2UgJiYgX3RoaXMucHJvcHMub25Dcm9wU2l6ZUNoYW5nZShjcm9wU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGNyb3BTaXplOiBjcm9wU2l6ZVxuICAgICAgICB9LCBfdGhpcy5yZWNvbXB1dGVDcm9wUG9zaXRpb24pO1xuICAgICAgICAvLyBwYXNzIGNyb3Agc2l6ZSB0byBwYXJlbnRcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnNldENyb3BTaXplKSB7XG4gICAgICAgICAgX3RoaXMucHJvcHMuc2V0Q3JvcFNpemUoY3JvcFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcm9wU2l6ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF90aGlzLnNhdmVDb250YWluZXJQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5jb250YWluZXJSZWYpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IF90aGlzLmNvbnRhaW5lclJlZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICAgICAgeTogYm91bmRzLnRvcFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgX3RoaXMub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5jdXJyZW50RG9jKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5jdXJyZW50RG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF90aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgIF90aGlzLmN1cnJlbnREb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLm9uRHJhZ1N0b3BwZWQpO1xuICAgICAgX3RoaXMuc2F2ZUNvbnRhaW5lclBvc2l0aW9uKCk7XG4gICAgICBfdGhpcy5vbkRyYWdTdGFydChDcm9wcGVyLmdldE1vdXNlUG9pbnQoZSkpO1xuICAgIH07XG4gICAgX3RoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLm9uRHJhZyhDcm9wcGVyLmdldE1vdXNlUG9pbnQoZSkpO1xuICAgIH07XG4gICAgX3RoaXMub25TY3JvbGwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5jdXJyZW50RG9jKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5zYXZlQ29udGFpbmVyUG9zaXRpb24oKTtcbiAgICB9O1xuICAgIF90aGlzLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLmN1cnJlbnREb2MpIHJldHVybjtcbiAgICAgIF90aGlzLmlzVG91Y2hpbmcgPSB0cnVlO1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uVG91Y2hSZXF1ZXN0ICYmICFfdGhpcy5wcm9wcy5vblRvdWNoUmVxdWVzdChlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpcy5jdXJyZW50RG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLm9uVG91Y2hNb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTsgLy8gaU9TIDExIG5vdyBkZWZhdWx0cyB0byBwYXNzaXZlOiB0cnVlXG4gICAgICBfdGhpcy5jdXJyZW50RG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX3RoaXMub25EcmFnU3RvcHBlZCk7XG4gICAgICBfdGhpcy5zYXZlQ29udGFpbmVyUG9zaXRpb24oKTtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIF90aGlzLm9uUGluY2hTdGFydChlKTtcbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBfdGhpcy5vbkRyYWdTdGFydChDcm9wcGVyLmdldFRvdWNoUG9pbnQoZS50b3VjaGVzWzBdKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfdGhpcy5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBQcmV2ZW50IHdob2xlIHBhZ2UgZnJvbSBzY3JvbGxpbmcgb24gaU9TLlxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgX3RoaXMub25QaW5jaE1vdmUoZSk7XG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgX3RoaXMub25EcmFnKENyb3BwZXIuZ2V0VG91Y2hQb2ludChlLnRvdWNoZXNbMF0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF90aGlzLm9uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMuY3VycmVudERvYykgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuY3VycmVudERvYy5hZGRFdmVudExpc3RlbmVyKCdnZXN0dXJlY2hhbmdlJywgX3RoaXMub25HZXN0dXJlTW92ZSk7XG4gICAgICBfdGhpcy5jdXJyZW50RG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVlbmQnLCBfdGhpcy5vbkdlc3R1cmVFbmQpO1xuICAgICAgX3RoaXMuZ2VzdHVyZVpvb21TdGFydCA9IF90aGlzLnByb3BzLnpvb207XG4gICAgICBfdGhpcy5nZXN0dXJlUm90YXRpb25TdGFydCA9IF90aGlzLnByb3BzLnJvdGF0aW9uO1xuICAgIH07XG4gICAgX3RoaXMub25HZXN0dXJlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoX3RoaXMuaXNUb3VjaGluZykge1xuICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIGNvbmZsaWN0IGJldHdlZW4gZ2VzdHVyZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludCA9IENyb3BwZXIuZ2V0TW91c2VQb2ludChlKTtcbiAgICAgIHZhciBuZXdab29tID0gX3RoaXMuZ2VzdHVyZVpvb21TdGFydCAtIDEgKyBlLnNjYWxlO1xuICAgICAgX3RoaXMuc2V0TmV3Wm9vbShuZXdab29tLCBwb2ludCwge1xuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25Sb3RhdGlvbkNoYW5nZSkge1xuICAgICAgICB2YXIgbmV3Um90YXRpb24gPSBfdGhpcy5nZXN0dXJlUm90YXRpb25TdGFydCArIGUucm90YXRpb247XG4gICAgICAgIF90aGlzLnByb3BzLm9uUm90YXRpb25DaGFuZ2UobmV3Um90YXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3RoaXMub25HZXN0dXJlRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLmNsZWFuRXZlbnRzKCk7XG4gICAgfTtcbiAgICBfdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIF9iLCBfYztcbiAgICAgIHZhciB4ID0gX2EueCxcbiAgICAgICAgeSA9IF9hLnk7XG4gICAgICBfdGhpcy5kcmFnU3RhcnRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICAgIF90aGlzLmRyYWdTdGFydENyb3AgPSBfX2Fzc2lnbih7fSwgX3RoaXMucHJvcHMuY3JvcCk7XG4gICAgICAoX2MgPSAoX2IgPSBfdGhpcy5wcm9wcykub25JbnRlcmFjdGlvblN0YXJ0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYik7XG4gICAgfTtcbiAgICBfdGhpcy5vbkRyYWcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciB4ID0gX2EueCxcbiAgICAgICAgeSA9IF9hLnk7XG4gICAgICBpZiAoIV90aGlzLmN1cnJlbnRXaW5kb3cpIHJldHVybjtcbiAgICAgIGlmIChfdGhpcy5yYWZEcmFnVGltZW91dCkgX3RoaXMuY3VycmVudFdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5yYWZEcmFnVGltZW91dCk7XG4gICAgICBfdGhpcy5yYWZEcmFnVGltZW91dCA9IF90aGlzLmN1cnJlbnRXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5jcm9wU2l6ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IHggLSBfdGhpcy5kcmFnU3RhcnRQb3NpdGlvbi54O1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IHkgLSBfdGhpcy5kcmFnU3RhcnRQb3NpdGlvbi55O1xuICAgICAgICB2YXIgcmVxdWVzdGVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogX3RoaXMuZHJhZ1N0YXJ0Q3JvcC54ICsgb2Zmc2V0WCxcbiAgICAgICAgICB5OiBfdGhpcy5kcmFnU3RhcnRDcm9wLnkgKyBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IF90aGlzLnByb3BzLnJlc3RyaWN0UG9zaXRpb24gPyByZXN0cmljdFBvc2l0aW9uKHJlcXVlc3RlZFBvc2l0aW9uLCBfdGhpcy5tZWRpYVNpemUsIF90aGlzLnN0YXRlLmNyb3BTaXplLCBfdGhpcy5wcm9wcy56b29tLCBfdGhpcy5wcm9wcy5yb3RhdGlvbikgOiByZXF1ZXN0ZWRQb3NpdGlvbjtcbiAgICAgICAgX3RoaXMucHJvcHMub25Dcm9wQ2hhbmdlKG5ld1Bvc2l0aW9uKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3RoaXMub25EcmFnU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBfdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XG4gICAgICBfdGhpcy5jbGVhbkV2ZW50cygpO1xuICAgICAgX3RoaXMuZW1pdENyb3BEYXRhKCk7XG4gICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25JbnRlcmFjdGlvbkVuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH07XG4gICAgX3RoaXMub25XaGVlbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLmN1cnJlbnRXaW5kb3cpIHJldHVybjtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbldoZWVsUmVxdWVzdCAmJiAhX3RoaXMucHJvcHMub25XaGVlbFJlcXVlc3QoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHBvaW50ID0gQ3JvcHBlci5nZXRNb3VzZVBvaW50KGUpO1xuICAgICAgdmFyIHBpeGVsWSA9IG5vcm1hbGl6ZVdoZWVsKGUpLnBpeGVsWTtcbiAgICAgIHZhciBuZXdab29tID0gX3RoaXMucHJvcHMuem9vbSAtIHBpeGVsWSAqIF90aGlzLnByb3BzLnpvb21TcGVlZCAvIDIwMDtcbiAgICAgIF90aGlzLnNldE5ld1pvb20obmV3Wm9vbSwgcG9pbnQsIHtcbiAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5oYXNXaGVlbEp1c3RTdGFydGVkKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBoYXNXaGVlbEp1c3RTdGFydGVkOiB0cnVlXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25JbnRlcmFjdGlvblN0YXJ0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLndoZWVsVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLndoZWVsVGltZXIpO1xuICAgICAgfVxuICAgICAgX3RoaXMud2hlZWxUaW1lciA9IF90aGlzLmN1cnJlbnRXaW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaGFzV2hlZWxKdXN0U3RhcnRlZDogZmFsc2VcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkludGVyYWN0aW9uRW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgMjUwKTtcbiAgICB9O1xuICAgIF90aGlzLmdldFBvaW50T25Db250YWluZXIgPSBmdW5jdGlvbiAoX2EsIGNvbnRhaW5lclRvcExlZnQpIHtcbiAgICAgIHZhciB4ID0gX2EueCxcbiAgICAgICAgeSA9IF9hLnk7XG4gICAgICBpZiAoIV90aGlzLmNvbnRhaW5lclJlY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQ3JvcHBlciBpcyBub3QgbW91bnRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogX3RoaXMuY29udGFpbmVyUmVjdC53aWR0aCAvIDIgLSAoeCAtIGNvbnRhaW5lclRvcExlZnQueCksXG4gICAgICAgIHk6IF90aGlzLmNvbnRhaW5lclJlY3QuaGVpZ2h0IC8gMiAtICh5IC0gY29udGFpbmVyVG9wTGVmdC55KVxuICAgICAgfTtcbiAgICB9O1xuICAgIF90aGlzLmdldFBvaW50T25NZWRpYSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHggPSBfYS54LFxuICAgICAgICB5ID0gX2EueTtcbiAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLFxuICAgICAgICBjcm9wID0gX2IuY3JvcCxcbiAgICAgICAgem9vbSA9IF9iLnpvb207XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoeCArIGNyb3AueCkgLyB6b29tLFxuICAgICAgICB5OiAoeSArIGNyb3AueSkgLyB6b29tXG4gICAgICB9O1xuICAgIH07XG4gICAgX3RoaXMuc2V0TmV3Wm9vbSA9IGZ1bmN0aW9uICh6b29tLCBwb2ludCwgX2EpIHtcbiAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICBfYyA9IF9iLnNob3VsZFVwZGF0ZVBvc2l0aW9uLFxuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbiA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2M7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmNyb3BTaXplIHx8ICFfdGhpcy5wcm9wcy5vblpvb21DaGFuZ2UpIHJldHVybjtcbiAgICAgIHZhciBuZXdab29tID0gY2xhbXAoem9vbSwgX3RoaXMucHJvcHMubWluWm9vbSwgX3RoaXMucHJvcHMubWF4Wm9vbSk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHpvb21Qb2ludCA9IF90aGlzLmdldFBvaW50T25Db250YWluZXIocG9pbnQsIF90aGlzLmNvbnRhaW5lclBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHpvb21UYXJnZXQgPSBfdGhpcy5nZXRQb2ludE9uTWVkaWEoem9vbVBvaW50KTtcbiAgICAgICAgdmFyIHJlcXVlc3RlZFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHpvb21UYXJnZXQueCAqIG5ld1pvb20gLSB6b29tUG9pbnQueCxcbiAgICAgICAgICB5OiB6b29tVGFyZ2V0LnkgKiBuZXdab29tIC0gem9vbVBvaW50LnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gX3RoaXMucHJvcHMucmVzdHJpY3RQb3NpdGlvbiA/IHJlc3RyaWN0UG9zaXRpb24ocmVxdWVzdGVkUG9zaXRpb24sIF90aGlzLm1lZGlhU2l6ZSwgX3RoaXMuc3RhdGUuY3JvcFNpemUsIG5ld1pvb20sIF90aGlzLnByb3BzLnJvdGF0aW9uKSA6IHJlcXVlc3RlZFBvc2l0aW9uO1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNyb3BDaGFuZ2UobmV3UG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgX3RoaXMucHJvcHMub25ab29tQ2hhbmdlKG5ld1pvb20pO1xuICAgIH07XG4gICAgX3RoaXMuZ2V0Q3JvcERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmNyb3BTaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBpcyB0byBlbnN1cmUgdGhlIGNyb3AgaXMgY29ycmVjdGx5IHJlc3RyaWN0ZWQgYWZ0ZXIgYSB6b29tIGJhY2sgKGh0dHBzOi8vZ2l0aHViLmNvbS9WYWxlbnRpbkgvcmVhY3QtZWFzeS1jcm9wL2lzc3Vlcy82KVxuICAgICAgdmFyIHJlc3RyaWN0ZWRQb3NpdGlvbiA9IF90aGlzLnByb3BzLnJlc3RyaWN0UG9zaXRpb24gPyByZXN0cmljdFBvc2l0aW9uKF90aGlzLnByb3BzLmNyb3AsIF90aGlzLm1lZGlhU2l6ZSwgX3RoaXMuc3RhdGUuY3JvcFNpemUsIF90aGlzLnByb3BzLnpvb20sIF90aGlzLnByb3BzLnJvdGF0aW9uKSA6IF90aGlzLnByb3BzLmNyb3A7XG4gICAgICByZXR1cm4gY29tcHV0ZUNyb3BwZWRBcmVhKHJlc3RyaWN0ZWRQb3NpdGlvbiwgX3RoaXMubWVkaWFTaXplLCBfdGhpcy5zdGF0ZS5jcm9wU2l6ZSwgX3RoaXMuZ2V0QXNwZWN0KCksIF90aGlzLnByb3BzLnpvb20sIF90aGlzLnByb3BzLnJvdGF0aW9uLCBfdGhpcy5wcm9wcy5yZXN0cmljdFBvc2l0aW9uKTtcbiAgICB9O1xuICAgIF90aGlzLmVtaXRDcm9wRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjcm9wRGF0YSA9IF90aGlzLmdldENyb3BEYXRhKCk7XG4gICAgICBpZiAoIWNyb3BEYXRhKSByZXR1cm47XG4gICAgICB2YXIgY3JvcHBlZEFyZWFQZXJjZW50YWdlcyA9IGNyb3BEYXRhLmNyb3BwZWRBcmVhUGVyY2VudGFnZXMsXG4gICAgICAgIGNyb3BwZWRBcmVhUGl4ZWxzID0gY3JvcERhdGEuY3JvcHBlZEFyZWFQaXhlbHM7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25Dcm9wQ29tcGxldGUpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25Dcm9wQ29tcGxldGUoY3JvcHBlZEFyZWFQZXJjZW50YWdlcywgY3JvcHBlZEFyZWFQaXhlbHMpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ3JvcEFyZWFDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25Dcm9wQXJlYUNoYW5nZShjcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLCBjcm9wcGVkQXJlYVBpeGVscyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfdGhpcy5lbWl0Q3JvcEFyZWFDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3JvcERhdGEgPSBfdGhpcy5nZXRDcm9wRGF0YSgpO1xuICAgICAgaWYgKCFjcm9wRGF0YSkgcmV0dXJuO1xuICAgICAgdmFyIGNyb3BwZWRBcmVhUGVyY2VudGFnZXMgPSBjcm9wRGF0YS5jcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLFxuICAgICAgICBjcm9wcGVkQXJlYVBpeGVscyA9IGNyb3BEYXRhLmNyb3BwZWRBcmVhUGl4ZWxzO1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ3JvcEFyZWFDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25Dcm9wQXJlYUNoYW5nZShjcm9wcGVkQXJlYVBlcmNlbnRhZ2VzLCBjcm9wcGVkQXJlYVBpeGVscyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfdGhpcy5yZWNvbXB1dGVDcm9wUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmNyb3BTaXplKSByZXR1cm47XG4gICAgICB2YXIgbmV3UG9zaXRpb24gPSBfdGhpcy5wcm9wcy5yZXN0cmljdFBvc2l0aW9uID8gcmVzdHJpY3RQb3NpdGlvbihfdGhpcy5wcm9wcy5jcm9wLCBfdGhpcy5tZWRpYVNpemUsIF90aGlzLnN0YXRlLmNyb3BTaXplLCBfdGhpcy5wcm9wcy56b29tLCBfdGhpcy5wcm9wcy5yb3RhdGlvbikgOiBfdGhpcy5wcm9wcy5jcm9wO1xuICAgICAgX3RoaXMucHJvcHMub25Dcm9wQ2hhbmdlKG5ld1Bvc2l0aW9uKTtcbiAgICAgIF90aGlzLmVtaXRDcm9wRGF0YSgpO1xuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIENyb3BwZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50RG9jIHx8ICF0aGlzLmN1cnJlbnRXaW5kb3cpIHJldHVybjtcbiAgICBpZiAodGhpcy5jb250YWluZXJSZWYpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lclJlZi5vd25lckRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuY3VycmVudERvYyA9IHRoaXMuY29udGFpbmVyUmVmLm93bmVyRG9jdW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50RG9jLmRlZmF1bHRWaWV3KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFdpbmRvdyA9IHRoaXMuY3VycmVudERvYy5kZWZhdWx0VmlldztcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgICAvLyBvbmx5IGFkZCB3aW5kb3cgcmVzaXplIGxpc3RlbmVyIGlmIFJlc2l6ZU9ic2VydmVyIGlzIG5vdCBzdXBwb3J0ZWQuIE90aGVyd2lzZSwgaXQgd291bGQgYmUgcmVkdW5kYW50XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuY29tcHV0ZVNpemVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMuem9vbVdpdGhTY3JvbGwgJiYgdGhpcy5jb250YWluZXJSZWYuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXJSZWYuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgdGhpcy5vbkdlc3R1cmVTdGFydCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudERvYy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICBpZiAoIXRoaXMucHJvcHMuZGlzYWJsZUF1dG9tYXRpY1N0eWxlc0luamVjdGlvbikge1xuICAgICAgdGhpcy5zdHlsZVJlZiA9IHRoaXMuY3VycmVudERvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgdGhpcy5zdHlsZVJlZi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgIGlmICh0aGlzLnByb3BzLm5vbmNlKSB7XG4gICAgICAgIHRoaXMuc3R5bGVSZWYuc2V0QXR0cmlidXRlKCdub25jZScsIHRoaXMucHJvcHMubm9uY2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdHlsZVJlZi5pbm5lckhUTUwgPSBjc3NfMjQ4ejtcbiAgICAgIHRoaXMuY3VycmVudERvYy5oZWFkLmFwcGVuZENoaWxkKHRoaXMuc3R5bGVSZWYpO1xuICAgIH1cbiAgICAvLyB3aGVuIHJlbmRlcmVkIHZpYSBTU1IsIHRoZSBpbWFnZSBjYW4gYWxyZWFkeSBiZSBsb2FkZWQgYW5kIGl0cyBvbkxvYWQgY2FsbGJhY2sgd2lsbCBuZXZlciBiZSBjYWxsZWRcbiAgICBpZiAodGhpcy5pbWFnZVJlZi5jdXJyZW50ICYmIHRoaXMuaW1hZ2VSZWYuY3VycmVudC5jb21wbGV0ZSkge1xuICAgICAgdGhpcy5vbk1lZGlhTG9hZCgpO1xuICAgIH1cbiAgICAvLyBzZXQgaW1hZ2UgYW5kIHZpZGVvIHJlZnMgaW4gdGhlIHBhcmVudCBpZiB0aGUgY2FsbGJhY2tzIGV4aXN0XG4gICAgaWYgKHRoaXMucHJvcHMuc2V0SW1hZ2VSZWYpIHtcbiAgICAgIHRoaXMucHJvcHMuc2V0SW1hZ2VSZWYodGhpcy5pbWFnZVJlZik7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLnNldFZpZGVvUmVmKSB7XG4gICAgICB0aGlzLnByb3BzLnNldFZpZGVvUmVmKHRoaXMudmlkZW9SZWYpO1xuICAgIH1cbiAgfTtcbiAgQ3JvcHBlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXRoaXMuY3VycmVudERvYyB8fCAhdGhpcy5jdXJyZW50V2luZG93KSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmN1cnJlbnRXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5jb21wdXRlU2l6ZXMpO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLnJlc2l6ZU9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lclJlZikge1xuICAgICAgdGhpcy5jb250YWluZXJSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgdGhpcy5wcmV2ZW50Wm9vbVNhZmFyaSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0eWxlUmVmKSB7XG4gICAgICAoX2IgPSB0aGlzLnN0eWxlUmVmLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmVDaGlsZCh0aGlzLnN0eWxlUmVmKTtcbiAgICB9XG4gICAgdGhpcy5jbGVhbkV2ZW50cygpO1xuICAgIHRoaXMucHJvcHMuem9vbVdpdGhTY3JvbGwgJiYgdGhpcy5jbGVhclNjcm9sbEV2ZW50KCk7XG4gIH07XG4gIENyb3BwZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICBpZiAocHJldlByb3BzLnJvdGF0aW9uICE9PSB0aGlzLnByb3BzLnJvdGF0aW9uKSB7XG4gICAgICB0aGlzLmNvbXB1dGVTaXplcygpO1xuICAgICAgdGhpcy5yZWNvbXB1dGVDcm9wUG9zaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHByZXZQcm9wcy5hc3BlY3QgIT09IHRoaXMucHJvcHMuYXNwZWN0KSB7XG4gICAgICB0aGlzLmNvbXB1dGVTaXplcygpO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzLm9iamVjdEZpdCAhPT0gdGhpcy5wcm9wcy5vYmplY3RGaXQpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVNpemVzKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2UHJvcHMuem9vbSAhPT0gdGhpcy5wcm9wcy56b29tKSB7XG4gICAgICB0aGlzLnJlY29tcHV0ZUNyb3BQb3NpdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoKChfYSA9IHByZXZQcm9wcy5jcm9wU2l6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgIT09ICgoX2IgPSB0aGlzLnByb3BzLmNyb3BTaXplKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSB8fCAoKF9jID0gcHJldlByb3BzLmNyb3BTaXplKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mud2lkdGgpICE9PSAoKF9kID0gdGhpcy5wcm9wcy5jcm9wU2l6ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLndpZHRoKSkge1xuICAgICAgdGhpcy5jb21wdXRlU2l6ZXMoKTtcbiAgICB9IGVsc2UgaWYgKCgoX2UgPSBwcmV2UHJvcHMuY3JvcCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLngpICE9PSAoKF9mID0gdGhpcy5wcm9wcy5jcm9wKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YueCkgfHwgKChfZyA9IHByZXZQcm9wcy5jcm9wKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cueSkgIT09ICgoX2ggPSB0aGlzLnByb3BzLmNyb3ApID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC55KSkge1xuICAgICAgdGhpcy5lbWl0Q3JvcEFyZWFDaGFuZ2UoKTtcbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcy56b29tV2l0aFNjcm9sbCAhPT0gdGhpcy5wcm9wcy56b29tV2l0aFNjcm9sbCAmJiB0aGlzLmNvbnRhaW5lclJlZikge1xuICAgICAgdGhpcy5wcm9wcy56b29tV2l0aFNjcm9sbCA/IHRoaXMuY29udGFpbmVyUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KSA6IHRoaXMuY2xlYXJTY3JvbGxFdmVudCgpO1xuICAgIH1cbiAgICBpZiAocHJldlByb3BzLnZpZGVvICE9PSB0aGlzLnByb3BzLnZpZGVvKSB7XG4gICAgICAoX2ogPSB0aGlzLnZpZGVvUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5sb2FkKCk7XG4gICAgfVxuICAgIHZhciBvYmplY3RGaXQgPSB0aGlzLmdldE9iamVjdEZpdCgpO1xuICAgIGlmIChvYmplY3RGaXQgIT09IHRoaXMuc3RhdGUubWVkaWFPYmplY3RGaXQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBtZWRpYU9iamVjdEZpdDogb2JqZWN0Rml0XG4gICAgICB9LCB0aGlzLmNvbXB1dGVTaXplcyk7XG4gICAgfVxuICB9O1xuICBDcm9wcGVyLnByb3RvdHlwZS5nZXRBc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgIGNyb3BTaXplID0gX2EuY3JvcFNpemUsXG4gICAgICBhc3BlY3QgPSBfYS5hc3BlY3Q7XG4gICAgaWYgKGNyb3BTaXplKSB7XG4gICAgICByZXR1cm4gY3JvcFNpemUud2lkdGggLyBjcm9wU2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBhc3BlY3Q7XG4gIH07XG4gIENyb3BwZXIucHJvdG90eXBlLmdldE9iamVjdEZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHRoaXMucHJvcHMub2JqZWN0Rml0ID09PSAnY292ZXInKSB7XG4gICAgICB2YXIgbWVkaWFSZWYgPSB0aGlzLmltYWdlUmVmLmN1cnJlbnQgfHwgdGhpcy52aWRlb1JlZi5jdXJyZW50O1xuICAgICAgaWYgKG1lZGlhUmVmICYmIHRoaXMuY29udGFpbmVyUmVmKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyUmVjdCA9IHRoaXMuY29udGFpbmVyUmVmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY29udGFpbmVyQXNwZWN0ID0gdGhpcy5jb250YWluZXJSZWN0LndpZHRoIC8gdGhpcy5jb250YWluZXJSZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9ICgoX2EgPSB0aGlzLmltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYXR1cmFsV2lkdGgpIHx8ICgoX2IgPSB0aGlzLnZpZGVvUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aWRlb1dpZHRoKSB8fCAwO1xuICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9ICgoX2MgPSB0aGlzLmltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYXR1cmFsSGVpZ2h0KSB8fCAoKF9kID0gdGhpcy52aWRlb1JlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudmlkZW9IZWlnaHQpIHx8IDA7XG4gICAgICAgIHZhciBtZWRpYUFzcGVjdCA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIHJldHVybiBtZWRpYUFzcGVjdCA8IGNvbnRhaW5lckFzcGVjdCA/ICdob3Jpem9udGFsLWNvdmVyJyA6ICd2ZXJ0aWNhbC1jb3Zlcic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ2hvcml6b250YWwtY292ZXInO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5vYmplY3RGaXQ7XG4gIH07XG4gIENyb3BwZXIucHJvdG90eXBlLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHBvaW50QSA9IENyb3BwZXIuZ2V0VG91Y2hQb2ludChlLnRvdWNoZXNbMF0pO1xuICAgIHZhciBwb2ludEIgPSBDcm9wcGVyLmdldFRvdWNoUG9pbnQoZS50b3VjaGVzWzFdKTtcbiAgICB0aGlzLmxhc3RQaW5jaERpc3RhbmNlID0gZ2V0RGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHBvaW50QSwgcG9pbnRCKTtcbiAgICB0aGlzLmxhc3RQaW5jaFJvdGF0aW9uID0gZ2V0Um90YXRpb25CZXR3ZWVuUG9pbnRzKHBvaW50QSwgcG9pbnRCKTtcbiAgICB0aGlzLm9uRHJhZ1N0YXJ0KGdldENlbnRlcihwb2ludEEsIHBvaW50QikpO1xuICB9O1xuICBDcm9wcGVyLnByb3RvdHlwZS5vblBpbmNoTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIXRoaXMuY3VycmVudERvYyB8fCAhdGhpcy5jdXJyZW50V2luZG93KSByZXR1cm47XG4gICAgdmFyIHBvaW50QSA9IENyb3BwZXIuZ2V0VG91Y2hQb2ludChlLnRvdWNoZXNbMF0pO1xuICAgIHZhciBwb2ludEIgPSBDcm9wcGVyLmdldFRvdWNoUG9pbnQoZS50b3VjaGVzWzFdKTtcbiAgICB2YXIgY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50QSwgcG9pbnRCKTtcbiAgICB0aGlzLm9uRHJhZyhjZW50ZXIpO1xuICAgIGlmICh0aGlzLnJhZlBpbmNoVGltZW91dCkgdGhpcy5jdXJyZW50V2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmUGluY2hUaW1lb3V0KTtcbiAgICB0aGlzLnJhZlBpbmNoVGltZW91dCA9IHRoaXMuY3VycmVudFdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRpc3RhbmNlID0gZ2V0RGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHBvaW50QSwgcG9pbnRCKTtcbiAgICAgIHZhciBuZXdab29tID0gX3RoaXMucHJvcHMuem9vbSAqIChkaXN0YW5jZSAvIF90aGlzLmxhc3RQaW5jaERpc3RhbmNlKTtcbiAgICAgIF90aGlzLnNldE5ld1pvb20obmV3Wm9vbSwgY2VudGVyLCB7XG4gICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBfdGhpcy5sYXN0UGluY2hEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgdmFyIHJvdGF0aW9uID0gZ2V0Um90YXRpb25CZXR3ZWVuUG9pbnRzKHBvaW50QSwgcG9pbnRCKTtcbiAgICAgIHZhciBuZXdSb3RhdGlvbiA9IF90aGlzLnByb3BzLnJvdGF0aW9uICsgKHJvdGF0aW9uIC0gX3RoaXMubGFzdFBpbmNoUm90YXRpb24pO1xuICAgICAgX3RoaXMucHJvcHMub25Sb3RhdGlvbkNoYW5nZSAmJiBfdGhpcy5wcm9wcy5vblJvdGF0aW9uQ2hhbmdlKG5ld1JvdGF0aW9uKTtcbiAgICAgIF90aGlzLmxhc3RQaW5jaFJvdGF0aW9uID0gcm90YXRpb247XG4gICAgfSk7XG4gIH07XG4gIENyb3BwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICBpbWFnZSA9IF9hLmltYWdlLFxuICAgICAgdmlkZW8gPSBfYS52aWRlbyxcbiAgICAgIG1lZGlhUHJvcHMgPSBfYS5tZWRpYVByb3BzLFxuICAgICAgdHJhbnNmb3JtID0gX2EudHJhbnNmb3JtLFxuICAgICAgX2IgPSBfYS5jcm9wLFxuICAgICAgeCA9IF9iLngsXG4gICAgICB5ID0gX2IueSxcbiAgICAgIHJvdGF0aW9uID0gX2Eucm90YXRpb24sXG4gICAgICB6b29tID0gX2Euem9vbSxcbiAgICAgIGNyb3BTaGFwZSA9IF9hLmNyb3BTaGFwZSxcbiAgICAgIHNob3dHcmlkID0gX2Euc2hvd0dyaWQsXG4gICAgICBfYyA9IF9hLnN0eWxlLFxuICAgICAgY29udGFpbmVyU3R5bGUgPSBfYy5jb250YWluZXJTdHlsZSxcbiAgICAgIGNyb3BBcmVhU3R5bGUgPSBfYy5jcm9wQXJlYVN0eWxlLFxuICAgICAgbWVkaWFTdHlsZSA9IF9jLm1lZGlhU3R5bGUsXG4gICAgICBfZCA9IF9hLmNsYXNzZXMsXG4gICAgICBjb250YWluZXJDbGFzc05hbWUgPSBfZC5jb250YWluZXJDbGFzc05hbWUsXG4gICAgICBjcm9wQXJlYUNsYXNzTmFtZSA9IF9kLmNyb3BBcmVhQ2xhc3NOYW1lLFxuICAgICAgbWVkaWFDbGFzc05hbWUgPSBfZC5tZWRpYUNsYXNzTmFtZTtcbiAgICB2YXIgb2JqZWN0Rml0ID0gdGhpcy5zdGF0ZS5tZWRpYU9iamVjdEZpdDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBvbk1vdXNlRG93bjogdGhpcy5vbk1vdXNlRG93bixcbiAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5vblRvdWNoU3RhcnQsXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZihlbCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY29udGFpbmVyUmVmID0gZWw7XG4gICAgICB9LFxuICAgICAgXCJkYXRhLXRlc3RpZFwiOiBcImNvbnRhaW5lclwiLFxuICAgICAgc3R5bGU6IGNvbnRhaW5lclN0eWxlLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKCdyZWFjdEVhc3lDcm9wX0NvbnRhaW5lcicsIGNvbnRhaW5lckNsYXNzTmFtZSlcbiAgICB9LCBpbWFnZSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgX19hc3NpZ24oe1xuICAgICAgYWx0OiBcIlwiLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKCdyZWFjdEVhc3lDcm9wX0ltYWdlJywgb2JqZWN0Rml0ID09PSAnY29udGFpbicgJiYgJ3JlYWN0RWFzeUNyb3BfQ29udGFpbicsIG9iamVjdEZpdCA9PT0gJ2hvcml6b250YWwtY292ZXInICYmICdyZWFjdEVhc3lDcm9wX0NvdmVyX0hvcml6b250YWwnLCBvYmplY3RGaXQgPT09ICd2ZXJ0aWNhbC1jb3ZlcicgJiYgJ3JlYWN0RWFzeUNyb3BfQ292ZXJfVmVydGljYWwnLCBtZWRpYUNsYXNzTmFtZSlcbiAgICB9LCBtZWRpYVByb3BzLCB7XG4gICAgICBzcmM6IGltYWdlLFxuICAgICAgcmVmOiB0aGlzLmltYWdlUmVmLFxuICAgICAgc3R5bGU6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBtZWRpYVN0eWxlKSwge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSB8fCBcInRyYW5zbGF0ZShcIi5jb25jYXQoeCwgXCJweCwgXCIpLmNvbmNhdCh5LCBcInB4KSByb3RhdGUoXCIpLmNvbmNhdChyb3RhdGlvbiwgXCJkZWcpIHNjYWxlKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpXG4gICAgICB9KSxcbiAgICAgIG9uTG9hZDogdGhpcy5vbk1lZGlhTG9hZFxuICAgIH0pKSA6IHZpZGVvICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiLCBfX2Fzc2lnbih7XG4gICAgICBhdXRvUGxheTogdHJ1ZSxcbiAgICAgIGxvb3A6IHRydWUsXG4gICAgICBtdXRlZDogdHJ1ZSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcygncmVhY3RFYXN5Q3JvcF9WaWRlbycsIG9iamVjdEZpdCA9PT0gJ2NvbnRhaW4nICYmICdyZWFjdEVhc3lDcm9wX0NvbnRhaW4nLCBvYmplY3RGaXQgPT09ICdob3Jpem9udGFsLWNvdmVyJyAmJiAncmVhY3RFYXN5Q3JvcF9Db3Zlcl9Ib3Jpem9udGFsJywgb2JqZWN0Rml0ID09PSAndmVydGljYWwtY292ZXInICYmICdyZWFjdEVhc3lDcm9wX0NvdmVyX1ZlcnRpY2FsJywgbWVkaWFDbGFzc05hbWUpXG4gICAgfSwgbWVkaWFQcm9wcywge1xuICAgICAgcmVmOiB0aGlzLnZpZGVvUmVmLFxuICAgICAgb25Mb2FkZWRNZXRhZGF0YTogdGhpcy5vbk1lZGlhTG9hZCxcbiAgICAgIHN0eWxlOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbWVkaWFTdHlsZSksIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfHwgXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwicHgsIFwiKS5jb25jYXQoeSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocm90YXRpb24sIFwiZGVnKSBzY2FsZShcIikuY29uY2F0KHpvb20sIFwiKVwiKVxuICAgICAgfSksXG4gICAgICBjb250cm9sczogZmFsc2VcbiAgICB9KSwgKEFycmF5LmlzQXJyYXkodmlkZW8pID8gdmlkZW8gOiBbe1xuICAgICAgc3JjOiB2aWRlb1xuICAgIH1dKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIsIF9fYXNzaWduKHtcbiAgICAgICAga2V5OiBpdGVtLnNyY1xuICAgICAgfSwgaXRlbSkpO1xuICAgIH0pKSwgdGhpcy5zdGF0ZS5jcm9wU2l6ZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3JvcEFyZWFTdHlsZSksIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuc3RhdGUuY3JvcFNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5jcm9wU2l6ZS5oZWlnaHRcbiAgICAgIH0pLFxuICAgICAgXCJkYXRhLXRlc3RpZFwiOiBcImNyb3BwZXJcIixcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcygncmVhY3RFYXN5Q3JvcF9Dcm9wQXJlYScsIGNyb3BTaGFwZSA9PT0gJ3JvdW5kJyAmJiAncmVhY3RFYXN5Q3JvcF9Dcm9wQXJlYVJvdW5kJywgc2hvd0dyaWQgJiYgJ3JlYWN0RWFzeUNyb3BfQ3JvcEFyZWFHcmlkJywgY3JvcEFyZWFDbGFzc05hbWUpXG4gICAgfSkpO1xuICB9O1xuICBDcm9wcGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB6b29tOiAxLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIGFzcGVjdDogNCAvIDMsXG4gICAgbWF4Wm9vbTogTUFYX1pPT00sXG4gICAgbWluWm9vbTogTUlOX1pPT00sXG4gICAgY3JvcFNoYXBlOiAncmVjdCcsXG4gICAgb2JqZWN0Rml0OiAnY29udGFpbicsXG4gICAgc2hvd0dyaWQ6IHRydWUsXG4gICAgc3R5bGU6IHt9LFxuICAgIGNsYXNzZXM6IHt9LFxuICAgIG1lZGlhUHJvcHM6IHt9LFxuICAgIHpvb21TcGVlZDogMSxcbiAgICByZXN0cmljdFBvc2l0aW9uOiB0cnVlLFxuICAgIHpvb21XaXRoU2Nyb2xsOiB0cnVlXG4gIH07XG4gIENyb3BwZXIuZ2V0TW91c2VQb2ludCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE51bWJlcihlLmNsaWVudFgpLFxuICAgICAgeTogTnVtYmVyKGUuY2xpZW50WSlcbiAgICB9O1xuICB9O1xuICBDcm9wcGVyLmdldFRvdWNoUG9pbnQgPSBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTnVtYmVyKHRvdWNoLmNsaWVudFgpLFxuICAgICAgeTogTnVtYmVyKHRvdWNoLmNsaWVudFkpXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIENyb3BwZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IENyb3BwZXIgYXMgZGVmYXVsdCwgZ2V0SW5pdGlhbENyb3BGcm9tQ3JvcHBlZEFyZWFQZXJjZW50YWdlcywgZ2V0SW5pdGlhbENyb3BGcm9tQ3JvcHBlZEFyZWFQaXhlbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-easy-crop/index.module.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-easy-crop/node_modules/tslib/tslib.es6.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-easy-crop/node_modules/tslib/tslib.es6.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZWFzeS1jcm9wL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1AsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtEQUFrRCxRQUFRO0FBQzFELHlDQUF5QyxRQUFRO0FBQ2pELHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQXVGLGNBQWM7QUFDdEgsdUJBQXVCLGdDQUFnQyxxQ0FBcUMsMkNBQTJDO0FBQ3ZJLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQiw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUM1SSwwQkFBMEIsNkJBQTZCLG9CQUFvQixnREFBZ0Qsa0JBQWtCO0FBQzdJO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsdUNBQXVDLFlBQVksS0FBSyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvZS1zaG9wLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVhc3ktY3JvcC9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzPzRlNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-easy-crop/node_modules/tslib/tslib.es6.js\n");

/***/ })

};
;